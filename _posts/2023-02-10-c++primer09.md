---
layout: single
title: "C++ primer 09"
categories: C++_primer
tags: [c++]
author_profile: false
#search: false
---

## vector에 요소 추가하기

벡터를 만들고 후에 값을 넣을 때가 많다 그럴땐 push_back을 사용해 실행 중에 요소를 추가할 수 있다 

Push_back은 벡터의 가장 마지막 요소 뒤에 요소를 추가한다

```c++
vector int v2;
for (int i = 0; i != 100; ++i)
  v2.push_back(i);
```

이렇게 0부터 99까지 벡터에 값을 넣어줄 수 있다

단 vector의 크기를 변경한다면 범위 for는 사용할 수 없다



## 다른 vector 연산

vector의 요소는 string처럼 접근 할 수 있다 예를 들면 범위 for가 있다

```c++
vector <int> v{0,1,2,3,4,5,6,7,8,9,};
for (auto &i : v)
  i *= i; //모든 요소에 대해 접근하면서 제곱해서 저장한다

for (auto i : v)
  cout << i << " "; //모든 요소를 출력한다
cout << endl;
```



* v.empty()

  string처럼 비어있으면 true, 비어있지 않으면 false를 반환

* v.size()

  v의 요소 개수를 반환(타입은 vector<int>::size_type)

* v.push_back(t)

  요소 맨 뒤에 값이 t인 요소를 v에 추가

* v[n]

  v에서 위치 n에 있는 요소에 대한 참조자를 반환

* v1 = v2

  v1의 요소를 v2의 요소 복사본으로 바꾼다

* v1 = {a,b,c}

  v1의 요소를 = 오른쪽 목록 초기화한 요소들로 바꾼다

* v1 == v2

  요소 수가 같고 요소 값도 같으면 참이다

* V1 != v2

  요소 수나 요소 값 하나라도 다르면 참이다

* <. <=, > , >=
  공통 요소가 같으면 요소 수가 적은 vector가 요소 수가 많은 vector보다 적다. 요소 값이 다를 때에는 서로 다른 첫 번째 요소의 값에 따라 결정된다

### vector 색인 계산하기

v[n] = v[n] + 1 등등 색인으로 찾아서 값을 수정할 수 있다. 이는 요소를 추가하는건 아니다.

그러므로 빈 vector에 첨자 연산을 하면 오류이다. 요소를 추가하는게 아니기 때문이다.

```c++
vector<int> ivec;
for(decltype(ivvec.size()) ix = 0; ix != 10; ++ix)
  ivec[ix] = ix; //ivec에는 요소가 없으므로 오류이다
```

이를 올바르게 하려면 push_back()을 사용한다

```c++
for(decltype(ivvec.size()) ix = 0; ix != 10; ++ix)
  ivec.push_back(ix);
```

# 반복자

첨자를 사용해 vector나 string의 요소를 접근할 수 있지만 일반적으로는 반복자라는 것을 사용한다

반복자를 통해 포인터처럼 객체에 간접적으로 접근할 수 있다 반복자를 사용해 요소를 가져올 수 있고 반복자에는 요소를 이동할 수 있는 연산이 있다 반복자도 포인터와 마찬가지로 유효할 수도 있고 그렇지 않을 수도 있는데 유효한 반복자는 컨테이너의 요소나 마지막 요소 바로 다음 위치를 나타내며 이 외에 다른 모든 반복자 값은 유효하지 않다

## 반복자 사용하기

포인터와 달리 반복자는 주소 연산자를 사용해 얻지 않는다 반복자를 사용하는 타입에는 반복자를 반환하는 멤버가 있는데 이런 타입에는 이름이 begin과 end인 멤버가 있다

begin멤버는 첫 번째 요소를 나타내는 반복자를 반환하고 end에서 반환한 반복자는 컨테이너의 마지막 요소 바로 다음에 위치한 반복자이다. 이 반복자는 해당 컨테이너의 끝을 지나 존재하지 않는 요소를 나타내므로 모든 요소를 처리했는지 나타내는 표시자로 사용한다

컨테이너가 비었을때 begin에서 반환하는 반복자는 end와 같다 즉 둘다 끝 지난 반복자라는 것이다

일반적으로 정확한 반복자 타입은 신경쓰지 않고 auto를 사용해 정의한다 (반복자 타입은 vector<int>::iterator 이다 string은 string::iterator)

const_iterator는 읽기만 할 수 있고 이 반복자를 이용해서 쓸 수는 없다(타입은 vector<int>::const_iterator, string::const_iterator)

일반적인 vector는 반복자와 const반복자 둘 다 사용할 수 있고 const vector는 const 반복자만 사용할 수 있다

### 반복자 연산

string의 첫 문자를 대문자로 바꾸는 프로그램이다

```c++
string s("some string");
if (s.begin() != s.end()) //s가 비어있지 않은지 확인한다
{
  auto it = s.begin(); //it은 s의 첫번째를 나타내는 반복자이다
  *it = toupper(*it); //그 문자를 반복자를 역참조해서 대문자로 만든다
}
```

* *iter

  반복자 iter로 나타내는 요소에 대한 참조자를 반환한다

* iter->mem 

  iter을 역참조해 대상 요소에서 이름이 mem인 멤버를 가져온다 (*iter).mem과 같다

* ++iter 

  컨테이너의 다음 요소를 지시하도록 iter증가

* --iter

  컨테이너의 이전 요소를 지시하도록 iter감소

* Iter1 == iter2

* Iter1 != iter2

  두 반복자를 비교한다 두 반복자가 같은 요소를 나타내거나 같은 컨테이너의 끝 지난 반복자이면 둘은 같다

### 반복자 이동하기

반복자에서는 증가 연산자를 사용해 다음 요소로 이동한다 정수에서는 1을 더한 결과가 정수 값이지만 반복자의 경우 결과는 반복자를 다음 위치로 이동한다.

end에서 반환한 반복자는 요소를 나타내지 않으므로 증가 혹은 감소 시키지 않아야 한다

증가 연산자를 사용해 string에 첫 단어를 대문자로 변경하는 프로그램을 반복자를 사용해 고칠 수 있다

```c++
for (auto it = s.begin(); it != s.end() && !isspace(*it); ++it) //s에 문자가 없거나 공백 문자를 만날 때까지 문자를 처리
  *it = toupper(*it); //현재 문자를 대문자로 변경
```

### begin과 end연산

begin과 end에서 반환하는 타입은 대상 컨테이너가 const일때는 const-iterator를 반환하고 const가 아닐때는 iterator를 반환한다

하지만 일반 반복자에서 읽기만 하고 기록하지 않는다는 const 타입을 사용하고 싶을 때, 특별히 const_iterator타입을 요청할 수 있도록 cbegin과 cend라는 새로운 함수 두가지가 있다

```c++
auto it3 = v.cbegin(); //it3는 vector<int>::const_iterator 타입이다
```

이 함수들은 vector나 string이 const인지 관계없이 const_iterator를 반환한다

### 역참조와 멤버 접근 결합하기

반복자를 역참조하면 그 반복자로 나타내는 객체를 얻는다. 만약 객체가 클래스 타입이면 그 객체의 멤버에 접근하려 할 수도 있다

예를 들어 string의 vector가 있어(vector<string>)지정한 요소가 비었는지 알아야 할 수 있다. it가 이 vector에 속한 반복자라면 it로 나타내는 string이 비었는지 다음처럼 확인할 수 있다

```c++
(*it).empty();
```

괄호는 it에 역참조 연산자를 적용하고 그 결과에 점 연선자를 적용함을 나타낸다. 괄호가 없으면 점 연산자를 결과 객체가 아니라 it에 적용한다

```c++
(*it).empty(); //it을 역참조 하고 결과 객체에 대해 empty를 호출한다
*it.empty(); //오류: it에서 empty로 멤버를 가져올려고 하지만 it는 반복자이며 empty멤버가 없다
```

이와 같은 표현식을 간단히 하기 위해 언어에서는 화살표 연산자를 사용한다. 포인터와 비슷하게 말이다.

```c++
it->mem; //두 표현식은 같다
(*it).mem;
```



주의 사항: 반복자를 사용하고 있는 컨테이너(vector)에 요소를 추가하지 말아야 한다



## 반복자 산술 연산

string과 vector는 한번에 여러 요소를 이동하는 연산도 할 수 있다 그리고 모든 관계 연산자를 지원한다 이를 반복자 산술 연산이라고 한다

### 반복자에서 산술 연산

반복자 산술 연산을 할 때 결과는 있는 위치어야 한다. 

예를 들면 vector 중앙에 가장 가까운 요소에 대한 반복자를 계산할 수 있다

```c++
auto mid = vi.begin() + vi.size() / 2;
```

만약 vi에 요소가 20개 있다면 vi.size() / 2 는 10이다. 이 예에서는 mid를 vi.begin() + 10으로 설정한다. vi[10]과 같다. 두 반복자를 상등비교하는 것 외에 관계 연산자를 사용해서 vector와 string을 비교할 수 있다

* iter + n

* Iter - n

  정수 값 n을 반복자에 더하거나 빼면 컨테이너 내 여러 요소를 앞으로 또는 뒤로 이동한 반복자를 반환한다. 결과로 나온 반복자는 반드시 컨테이너 내 있는 요소여야 한다.(끝 지난 반복자까지)

* iter1 += n

* Iter1 -= n

  반복자 복합 연산자

* iter1 - iter2

  두 반복자를 빼면 오른쪽 반복자에 더해 왼쪽 반복자가 되는 수를 반환한다 결과는 두 반복자 사이 거리이다. 결과로 나온 반복자는 반드시 컨테이너 내에 있는 요소여야 한다.(끝 지난 반복자 까지)(타입은 difference_type)

* \>, >=, <, <=

  반복자로 지시하고 있는 요소가 같은 컨테이너 내에서 다른 반복자로 지시하는 요소보다 먼저 나타난다면 그 반복자는 다른 반복자보다 작다. 

### 반복자 산술 연산 사용하기

이진 검색이 있다. 정렬한 순차열에서 특정 값을 찾는데 순차열의 중앙에 가장 가까운 요소를 찾으며 연산한다. 해당 요소가 찾는 것이면 마치고, 찾는 거보다 작으면 그 요소 이후 것만을 대상으로 계속 검색한다. 찾는 거보다 크면 그 요소 이전 것까지 전반에 있는 것만을 대상으로 계속 찾는다. 줄어든 범위에서 중앙에 위치한 요소를 새로 계산하고 요소를 찾거나 검색할 대상이 없을 때까지 계속 검색한다

```c++
//texts는 반드시 정렬된 상태, 	beg와 end는 검색할 범위를 나타냄

auto beg = text.begin(), end = text.end();
auto mid = text.begin() + (end - beg) / 2; //원래 중앙점

while(mid != end && *mid != sought) //살펴볼 요소가 있고 아직 못찾았다면
{
  if (sought < *mid) //찾는 요소가 중앙점보다 작다면
    end = mid; //끝점을 중앙으로 조정해 후반을 무시한다
  else //찾는 요소가 중앙보다 크다면
    beg = mid + 1; //시작점을 중앙 + 1 지점으로 한다
  mid = beg + (end - beg) / 2; //새로운 중앙점 지정
}
```

# 배열

배열은 vector과 비슷하지만 크기가 고정이라 선언 후 요소를 추가 할 수 없다. 

## 내장 타입 정의와 초기화하기

배열의 크기는 반드시 상수 표현식이어야 한다.

```c++
unsigned cnt = 42; //상수 표현식이 아니다
constexpr unsigned sz = 42; //상수 표현식이다

int arr [10]; //int요소가 10개인 배열
int *parr[sz]; //int에 대한 포인터가 42개인 배열
string bad[cnt]; //오류: cnt는 상수 표현식이 아니다
string strs[get_size()]; //get_size()가 constexpr이면 좋음, 그렇지 않으면 오류이다
```

배열을 정의할 때는 auto를 사용할 수 없으며, 참조자를 담는 배열은 존재하지 않는다

### 배열 요소를 명시적으로 초기화 하기

배열 목록을 목록 초기화 할 수 있으며 이땐 배열 크기(차원)을 생략할 수 있다

```c++
const unsigned sz = 3;
int ia1[sz] = {0,1,2}; //값이 0,1,2인 int 요소가 3개인 배열
int a2[] = {0,1,2}; //차원이 3인 배열
int a3[5] = {0,1,2}; //a3[] = {0,1,2,0,0};과 같다
string a4[3] = {"hi", "bye"}; //a4[] = {"hi", "bye", " "}와 같다
int a5[2] = {0,1,2}; //오류: 초기 값이 너무 많다
```

### 문자 배열

문자배열은 문자열 상수를 사용해 초기화 할 수도 있다이 초기화 형식을 사용할 때는 문자열 상수 끝에 널 문자가 있다는걸 기억하는 것이 중요하다

```c++
char a1[] = {'c','+','+'}; //목록 초기화이며 null문자가 없다
char a2[] = {'c','+','+','\0'}; //목록 초기화이며 명시적으로 널문자 추가
char a3[] = "C++"; //널문자를 자동으로 추가
const char a4[6] = "Daniel"; //오류: 널문자를 넣을 공간이 없다
```

### 복사 대입 금지

배열은 다른 배열의 복사본으로 초기화 할 수 없을 뿐만 아니라 배열을 다른 배열에 대입하는 것도 안된다

```c++
int a[] = {0,1,2}; //int가 3인 배열
int a2[] = a; //오류: 배열을 다른 배열로 초기화 할 수 없다
a2 = a; //오류: 배열을 다른 배여에 대입할 수 없다
```

### 복잡한 배열 선언 이해하기

배열에는 대부분의 타입 객체를 담을 수 있다 배열은 직관적이지만 배열에 대한 포인터나 참조자를 정의하는 방법은 다소 복잡하다

```c++
int *ptrs[10]; //ptrs는 int에 대한 포인터가 10개인 배열
int &refs[10] = /* ? */; //오류: 참조자의 배열은 없음
int (*Parray)[10] = &arr; //Parraysms int가 10개인 배열을 가리킨다
int (&arrRef)[10] = arr; //arrRef는 intrk 10개인 배열을 참조한다
```

기본적으로 타입 변경자는 오른쪽에서 왼쪽으로 결합한다. Ptrs 정의는 오른쪽에서 왼쪽으로 읽으면 쉽다. 크기가 10이고 이름이 ptrs인 배열을 정의하며 이 배열에는 int에 대한 포인터를 담는다

Parray 정의는 오른쪽에서 왼쪽으로 읽는게 그리 도움이 되지 않는다. 배열 차원이 선언하는 이름 다음에 오므로 배열 선언을 오른쪽에서 왼쪽으로 읽기보다 안에서 밖으로 읽는 것이 더 쉬울 수 있다.

먼저 *Parray를 둘러싼 괄호를 보면 Parray가 포인터임을 알 수 있다 오른쪽을 보면 Parray에서 크기가 10인 배열을 가리킴을 알 수 있으며 왼쪽을 보면 배열 요소가 int임을 알 수 있다 즉 Parray는 intrk 10개인 배열에 대한 포인터이다.

마찬가지로 &arrRef는 arrRef가 참조자임을 나타낸다 이 참조자에서 참조하는 타입은 크기가 10인 배열이고 이 배열에서는 int 타입 요소를 담는다

물론 쓸 수 있는 타입 변경자 수에는 제한이 없다

```c++
int *(&arry)[10] = ptrs; //arry는 포인터가 10개인 배열에 대한 참조자이다
```

이 선언을 안에서 밖으로 읽으면 arry가 참조자임을 알 수 있고 오른쪽을 보면 arry에서 참조하는 객체는 크기가 10인 배열이고 왼쪽을 보면 요소 타입이 int에 대한 포인터임을 알 수 있다. 즉 arry는 int 포인터가 10개인 배열에 대한 참조자이다

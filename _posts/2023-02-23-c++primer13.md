---
layout: single
title: "C++ primer 13"
categories: C++_primer
tags: [c++]
author_profile: false
#search: false
---
## 멤버 접근 연산자

```c++
(*ptr).mem;
ptr->mem;// 두 표현은 같다
```

```c++
string s1 = "a string", *p = &s1; 
auto n = s1.size();
n = (*p).size();
n = p->size();
```

역참조는 .보다 우선순위가 낮으므로 사용할려면 괄호를 사용해야 한다

화살표 연산자는 포인터를 피연산자로 쓰고 좌변 값을 반환한다.

점 연산자에서는 멤버를 가져올 대상 객체가 좌변 값이면 좌변 값을 반환하고 그렇지 않으면 우변 값을 결과로 반환한다.



## 조건 연산자

```c++
string finalgrade = (grade < 60) ? "fall" : "pass";
```

? : 형태로 이루워져 있으며 ? 좌변에 있는 식이 참이면 : 왼쪽에 있는 값을 반환하고, 거짓이면 오른쪽에 있는 값을 반환한다.

조건 연산자 결과는 표현식이 모두 좌변 값이거나 공통인 좌변 값 타입으로 변환할 수 있을 때 좌변 값이다. 그렇지 않으면 결과는 우변 값이다.

### 중첩한 조건 연산자

조건 연산자를 다른 조건 연산자 안에 중첩할 수 있다

```c++
finalgrade = (grade > 90) ? "high pass" : (grade < 60) ? "fall" : "pass";
```

첫번째 조건에서는 grade가 90 이상이면 high pass고 아니라면 아래의 삼항 연산자를 실행한다. grade가 60보다 작으면 fall이고 크면 pass이다

중첩 조건 연산자는 2~3개 이상 안쓰는 것이 좋다.

### 출력 표현식에서 조건 연산자 사용하기

조건 연산자는 우선순위가 꽤 낮으므로 큰 표현식에 조건 표현식을 넣을 때에는 일반적으로 조건을 나타내는 하위 표현식을 괄호로 둘러싸야 한다.

조건 표현식을 괄호로 완전히 감싸지 않으면 오류가 난다

```c++
cout << ((grade < 60) ? "fall" : "pass") << endl;
```

## 비트 연산자

부호 비트 처리를 보장하는 방법은 없으므로 비트 연산자에는 unsigned 타입을 사용하길 강력히 권고한다.

### 비트 이동 연산자

```c++
bits >> 8; //bit를 오른쪽으로 8칸 이동한다
bits << 6; //bit를 왼쪽으로 6칸 이동한다
```

이동한 비트가 끝을 벗어나면 버린다

왼쪽 이동 연산자는 오른쪽에 값이 0인 비트를 채운다

오른쪽 이동 연산자는 왼쪽에 값이 0인 비트를 채우고, 부호 있는 타입이면 결과는 구현에 따라 다른데 부호 비트와 값이 0인 비트 중 하나로 왼쪽을 채운다

### 비트 NOT 연산자

비트 NOT연산자(~ 연산자)에서는 피연산자의 비트를 반전한다. 1인 비트는 0으로, 0인 비트는 1로 설정한다

```c++
unsigned char bits = 0027;//1001 0111
//char는 int로 승격하는데 승격할때 값은 그대로이고 상위 위치에 0을 추가한다. 24비트로 변경되고, 승격하면서 추가한 비트는 ~를 만나면 1로 전부 반전된다.
~bits;
//11111111 11111111 11111111 01101000
```

### 비트 AND, OR, XOR 연산자

```c++
unsigned char b1 = 0145; //0110 0101
unsigned char b2 = 0257; //1010 1111
b1 & b2; //0010 0101 : and연산자 두 비트가 모두 1이어야지 1
b1 | b2; //1110 1111 : or연산자 비트 하나라도 1이면 1
b1 ^ b2; //1100 1010 : xor연산자 두 비트중 하나만 1이면 1
```

## sizeof 연산자

sizeof연산자는 표현식이나 타입 이름의 크기를 바이트 단위로 반환한다. 이 연산자는 오른쪽 결합이다. 

Sizeof 결과는 타입이 size_t인 상수표현식이다. 사용 형식은 2가지 이다

* sizeof (타입)
* Sizeof 표현식

두번째 형식은 표현식에서 반환하는 타입의 크기를 반환한다. Sizeof 연산자는 다른 것과 달리 피연산자를 평가하지 않는다

```c++
Sales_data data, *p; //클래스 포인터?
sizeof(Sales_data); //객체를 담을 수 있는 클래스의 크기
sizeof data; //data의 타입 크기 즉 위랑 같다
sizeof p; //포인터의 크기
sizeof *p; //포인터가 가리키는 타입의 크기 즉, sizeof(Sales_data)
sizeof data.revenue; //Sales_data의 revenue 멤버의 타입 크기
sizeof Sales_data::revenue; //revenue의 크기를 얻는 다른 방법
```

p가 유효하지 않은 포인터여도 (미초기화 포인터)여도 직접 사용하는 것이 아니기 때문에 sizeof에서는 미초기화한 포인터를 역참조해도 오류가 발생하지 않는다. 그리고 sizeof에서는 클래스 멤버의 크기를 알고 싶어도 객체(멤버)를 지정하지 않아도 크기를 알 수 있다

* sizeof char 또는 char 타입 표현식은 1을 보장한다
* Sizeof 참조자 타입은 참조하는 타입의 객체 크기를 반환한다
* Sizeof 포인터는 포인터를 담을 수 있는 크기를 반환한다
* Sizeof 역참조한 포인터는 포인터에서 가리키는 타입의 객체 크기를 반환하는데 그 포인터는 유효하지 않아도 된다
* Sizeof 배열은 전체 배열 크기이며 이는 sizeof 요소 타입을 얻어 배열 요소 수를 곱한 것과 같다. sizeof에서는 배열을 포인터로 변환하지 않음에 주의한다
* Sizeof string 또는 vector 타입은 이 타입의 고정 부분에 대한 크기만을 반환하며 해당 객체의 요소에서 사용한 크기는 반환하지 않는다

Sizeof에서는 전체 배열 크기를 반환하므로 배열 크기를 요소 크기로 나눠 배열 요소수를 얻을 수 있다.

```c++
constexpr size_t sz = sizeof(ia) / sizeof(*ia); //ia 요소 수를 반환한다
int arr2[sz]; //좋음 : sizeof에서는 상수 표현식을 반환한다
```

## 쉼표 연산자

쉼표 연산자는 피연산자 둘을 취하고 왼쪽에서 오른쪽으로 평가한다 

```c++
vector<int>::size_type cnt = ivec.size();

for(vector<int>::size_type ix = 0; ix != ivec.size();++ix,--cnt)
  ivec[ix] = cnt;
```

For 루프가 돌 때마다 ix는 증가하고 cnt는 감소한다

## 타입 변환

타입이 비슷하면 c++에서는 프로그래머 간섭 없이 자동으로 형 변환 하기도 하는데 이를 암시적 변환이라고 한다.

암시적 변환이 일어날 때

* 표현식 대부분에서 int보다 작은 정수 타입 값은 먼저 적합한 더 큰 정수 타입으로 승격한다
* 조건에서 bool이 아닌 표현식은 bool로 변환한다
* 초기화에서 초기 값은 해당 변수 타입으로 변환한다. 대입에서 오른쪽 피연산자는 왼쪽 피연산자 타입으로 변환한다.
* 변환은 함수 호출과정에서도 일어난다

### 산술 변환

산술 변환은 어떤 산술 타입을 다른 타입으로 변경한다. 

정수값과 부동소수점 값이 있으면 정수 값을 적절한 부동소수점 값으로 변환한다

#### 정수 승격

작은 정수 타입을 더 큰 정수 타입으로 변환한다

bool, char, signed char, unsigned char, short, unsigned short는 각 타입별로 가능한 모든 값이 int와 맞으면 int로 승격하고 맞지 않으면 unsigned int로 승격한다. bool은 false일때 0, true일때 1로 변환한다

더 큰 char 타입(wchar_t, char16_t, char32_t)는 문자 타입별로 가능한 모든 값이 맞는 int이상의 타입 중에서 가장 작은 타입으로 승격한다

#### 부호 없는 타입인 피연산자

int 타입과 unsigned int 타입이 있으면 int를 unsigned int타입으로 바꾼다

이외의 타입 변환은 책을 참고

### 다른 암시적 변환

산술 변환 이외에도 여러 암시적 변환이 있다. 

* 배열을 포인터로 변환

  표현식 대부분에서 배열을 사용하면 이 배열은 자동으로 해당 배열의 첫 요소에 대한 포인터로 변환한다.

  ```c++
  int ia[10]; //int가 10개인 배열 
  int* ip = ia; //ia의 첫 요소를 포인터로 변환
  ```

  배열을 decltype과 함께 사용하거나 주소연산자, sizeof, typeid연산자의 피연산자로 사용할 때는 이 변환을 하지 않는다 또, 배열에 대한 참조자를 초기화 할 때도 이 변환을 하지 않는다

* 포인터 변환

  상수 정수 값 0과 상수 nullptr은 어떤 포인터 타입으로도 변환할 수 있다

  const가 아닌 타입에 대한 포인터는 

  ```c++
  void*
  ```

  로 변환할 수 있으며 가리키는 타입에 관계없이 포인터는 

  ```c++
  const void*
  ```

  로 변환할 수 있다 

  상속과 관계 있는 타입에 적용하는 포인터 변환도 있으며 이는 이후에 배운다

* bool로 변환

  산술 또는 포인터 타입을 자동으로 bool로 변환한다. 포인터나 산술 값이 0일때 이 변환에서는 false를 반환하고 그 외 다른 값일 때는 true를 반환한다

  ```c++
  char *cp = get_string();
  if (cp) /*...*/ //포인터 cp가 0이 아니면 true
  while (*cp) /*...*/ //*cp가 널 문자가 아니면 true
  ```

* const로 변환

  const가 아닌 타입에 대한 포인터를 const인 해당 타입에 대한 포인터로 변환할 수 있으며 참조자일 경우에도 비슷하다

  ```c++
  int i;
  const int &j = i; //const가 아닌 타입을 const int에 대한 참조자로 변환한다
  const int *p = &i; //const가 아닌 타입의 주소를 const 타입의 주소로 변환한다
  int &r = j, *q = p; //오류: const에서 const가 아닌 타입으로 변환할 수 없다
  ```

  하위 const를 제거하는 역변환은 없다

* 클래스 타입에서 정의한 변환

  클래스타입에서는 컴파일러에서 자동으로 적용할 변환을 정의할 수 있다. 컴파일러에서는 클래스 타입 변환을 한번에 단 하나만 적용한다. 여러 변환은 이후에 배운다

  지금까지 예로 든 프로그램에서도 이미 클래스 타입 변환을 사용했다

  string라이브러리를 기대하는 곳에 c형식 문자열을 사용할 때와 조건에서 istream을 사용해 값을 읽을 때 클래스 타입 변환을 사용한다.

  ```c++
  string s, t = "a value"; //문자열 상수를 string 타입으로 변환한다
  while (cin >> s) //while 조건에서 cin을 bool롤 변환한다
  ```

  조건 (cin >> s)에서는 cin을 읽고 cin을 결과로 반환한다. 조건에서는 bool 타입을 기대하지만 이 조건에서는 istream 타입 값을 확인한다. IO라이브러리에서는 istream을 bool로 변환할 수 있게 정의하므로 이 변환을 사용해 자동으로 cin을 bool로 변환한다. 결과로 얻는 bool 값은 스트림 상태에 따라 다르다. 마지막 읽기를 성공하면 이 변환으로 true를 반환하고 마지막 시도를 실패하면 bool로 변환했을 때 false를 반환한다



### 명시적 변환

때로는 명시적으로 객체를 강제로 다른 타입으로 변환하길 바라기도 한다 

#### 명명한 캐스트

캐스트 형식은 다음과 같다

캐스트이름 <타입> (표현식);

타입은 변환 목표 타입이고 표현식은 캐스트 할 값이다. 타입이 참조자이면 결과는 좌변값이다.

캐스트이름은 static_cast, dynamic_cast, const_cast,reinterpret_cast중에 하나이다 

#### static_cast

하위 const를 포함한 변환을 제외하고 모든 명확한 타입 변환은 static_cast를 사용해서 요청할 수 있다.

예를 들어 다음 표현식에서 피연산자 중 하나를 double로 캐스팅해 강제로 부동소수점 나눗셈을 사용하도록 할 수 있다.

```c++
double slope = static_cast<double>(j) / i;
```

Static_cast는 흔히 더 큰 산술 타입을 작은 타입에 대입할 때 유용하다 그리고 컴퍼일러에서 자동으로 하지 않는 변환을 할 때도 유용하다.

예를 들어 static_cast를 사용해 void* 포인터에 저장한 포인터 값을 회복할 수 있다

```c++
void* p = &d;
double *dp = static_cast<double*>(p);
```

이렇게 변환해도 포인터 값을 보존해준다.

#### dynamic_cast

이는 뒤에 배운다

#### const_cast

Const_cast는 피연산자의 하위 const만을 변경한다

```c++
const char *pc; //포인터가 const char형식을 가리킴(하위 const)
char *p = const_cast<char*>(pc); //좋음 : 하지만 p를 통해 기록하는 것은 미정의이다
```

객체에서 const를 날려버리면 더 이상 그 객체에 기록하는 것을 막지 않는다 

대상 객체가 원래 const가 아니었으면 캐스트를 사용해 기록할 수 있게 접근하는 것은 올바르다. 하지만 const인 객체에 기록하기 위해 const_cast를 사용하는 것은 미정의이다.

Const_cast는 표현식에서 상수 속성을 변경할 때만 사용할 수 있다. 다른 명명한 캐스트 형식으로 표현식에서 const 여부를 바꾸려 하면 컴파일 오류가 발생한다. 마찬가지로 const_cast를 사용해 표현식 타입을 바꿀 수도 없다. 

Const_cast는 다중 정의한 함수와 함께 사용할 때 가장 유용하며 이는 뒤에 배운다.

```c++
const char *cp;
char *q = static_cast<char*> (cp);
static_cast<string>(cp); //좋음: 문자열 상수를 string으로 변환한다
const_cast<string>(cp); //오류: const_cast는 상수 속성만 바꿀 수 있다
```

#### reinterpret_cast

Reinterpret_cast는 일반적으로 피연산자 비트 구성 형식을 저수준에서 재해석한다 예를 들어 다음 캐스트에서 

```c++
int *ip;
char *pc = reinterpret_cast<char*>(ip);
```

pc로 가리키는 실제 객체는 문자가 아니라 int라는 것을 잊지 말아야 한다 pc를 보통의 문자 포인터로 가정하고 사용하면 실행중 오류가 발생한다

인터넷을 더 참고해야겠다. 책은 뭔소린지 모르겠다 대충 알겠는데 설명을 못하겠네

#### 구식 캐스트

우리가 흔히 쓰는 (바꿀 타입)변수 이다. 이는 c++에서는 덜 사용하기를 추천한다

그리고 캐스트를 되도록이면 피하자

## 연산자 우선순위 표


---
layout: single
title: "C++/python 자료구조 -리스트와 딕셔너리(순차 컨테이너와 연관 컨테이너)"
categories: codingtest_C++/python
tags: [c++,python,codingtjest]
author_profile: false
#search: false
---

# 리스트(순차 컨테이너)

## list() - 파이썬

### 요약

파이썬에선 리스트를 사용하면 스택을 사용할지, 큐를 사용할지 고민하지 않아도 되며, 스택과 큐에 사용 가능한 모든 연산을 함께 제공한다.

|      연산      | 시간 복잡도 |                             설명                             |
| :------------: | :---------: | :----------------------------------------------------------: |
|     len(a)     |    O(1)     |                 전체 요소의 개수를 리턴한다                  |
|      a[i]      |    O(1)     |                  인덱스 i의 요소를 가져온다                  |
|     a[i:j]     |    O(k)     | 인덱스 i부터 j-1까지 슬라이스의 길이만큼인 k개의 요소를 가죠온다. 이 경우 객체 k개에 대한 조회가 필요하므로 O(k)이다 |
|   elem in a    |    O(n)     | elem 요소가 존재하는지 확인한다. 처음부터 순차 탐색하므로 n만큼 시간이 소요된다 |
| a.count(elem)  |    O(n)     |                  elem요소의 개수를 리턴한다                  |
| a.index(elem)  |    O(n)     |                 elem요소의 인덱스를 리턴한다                 |
| a.append(elem) |    O(1)     |             리스트 마지막에 elem요소를 추가한다              |
|    a.pop()     |    O(1)     |        리스트 마지막 요소를 추출한다. 스택의 연산이다        |
|    a.pop(0)    |    O(n)     | 리스트 첫번째 요소를 추출한다. 큐의 연산이다. 이 경우 전체 복사가 필요하므로 O(n)이다. 나중에 다시 살펴보겠지만 큐의 연산을 주로 사용한다면 리스트보다는 O(1)이 가능한 데크를 권장한다. |
|    del a[i]    |    O(n)     |            i에 따라 다르다. 최악의 경우 O(n)이다.            |
|   a.sort( )    | O(n log n)  | 정렬한다. 팀소트를 사용하며 최선의 경우에도 O(n)에도 실행될 수 있다. |
| min(a), max(a) |    O(n)     | 최솟값/최댓값을 계산하기 위해서는 전체를 선형 탐색해야 한다. |
|  a.reverse( )  |    O(n)     | 뒤집는다. 리스트는 입력 순서가 유지되므로 뒤집게 되면 입력 순서가 반대로 된다. |

### 사용 방법

#### 리스트 생성

```python
a = list() #기본 선언방식
a = [ ] #간단하게
a = [1,2,3] #초기값을 지정해 선언 가능, 요소끼리 다른 자료형도 추가 가능
```

#### 리스트 요소 추가

* append( )

  리스트의 제일 뒤에 요소 추가

  ```py
  a.append(4) #[1,2,3,4]
  ```

* insert( )

  특정 위치의 인덱스를 지정해 요소 추가

  ```py
  a.insert(3,5) #3번째 인덱스에 5를 추가 -> [1,2,3,5,4]
  ```

#### 리스트 요소 찾기(슬라이싱)

파이썬 인덱스는 0부터 시작

```python
#a = [1,2,3,5,4]
a[3] #5 반환
a[1:3] #인덱스 1부터 3 이전까지 -> [2,3] 반환
a[:3] #처음부터 3 이전까지 -> [1,2,3] 반환
a[4:] #인덱스 4부터 마지막까지 -> 5 반환
a[1:4:2] #세번째 파라미터는 몇 칸씩 건너뛸지 여부이다 -> [2,5] 반환
```

#### 리스트 요소 삭제

* del

  특정 위치의 인덱스로 삭제하기

  ```py
  a = [1,2,3,5,4]
  del a[1] #인덱스 1에 있는 2 삭제 -> [1,3,5,4]
  ```

* remove( )

  값으로 삭제하기

  ```py
  a.remove(3) #값이 3인 요소 삭제 -> [1,5,4]
  ```

* pop( )

  스택의 팝 연산과 비슷하다. 인덱스를 작성하지 않으면 가장 마지막 요소를 반환 후 삭제하고, 인덱스를 작성하면 그 인덱스 값을 리턴하고 삭제된다.

  ```py
  a = [1,2,3,5,4]
  a.pop() #마지막 인덱스를 반환하고 삭제 -> 4 반환 후 [1,2,3,5]
  a.pop(3) #인덱스 3을 반환하고 삭제 -> 5 반환 후 [1,2,3]
  ```

  

## 순차컨테이너-c++

### 요약

#### 순차 컨테이너 종류

* vector

  가변 크기 배열

  장점 : 빠른 접근 지원(인덱스)

  단점 : 끝 이외에서 요소를 삽입하거나 삭제하면 느려짐

* deque

  끝이 양쪽인 큐

  장점 : 빠른 접근 지원(인덱스), 처음 또는 끝에서 삽입/삭제가 빠르다

  단점 : 가운데에 요소를 추가하거나 이동하면 느려짐

* list

  이중 연결 리스트

  장점 : 모든 지점에서 삽입/삭제가 빠르다

  단점 : 양방향 순차 접근만 지원함

* forward_list

  단일 연결 리스트

  장점 : 모든 지점에서 삽입/삭제가 빠르다

  단점 : 단방향 순차 접근만 지원함, size연산이 없다

* array

  고정 크기 배열

  장점 : 빠른 접근 지원(인덱스), 내장 배열보다 안전하고 사용하기 쉬움

  단점 : 요소를 추가하거나 제거할 수 없다, 배열 크기를 변경할 수 없음

* string

  문자를 담는 특별한 컨테이너, vector와 비슷

  장점 : 빠른 접근 지원(인덱스), 끝에서 삽입 삭제 빠름

  단점 : 끝 이외에서 요소를 삽입하거나 삭제하면 느려짐



### 사용 방법

#### 사용할 순차 컨테이너 결정하기

사용할 컨테이너를 선택할 때 다음 원칙을 고려해볼 수 있다.

* 다른 컨테이너를 사용할 이유가 없으면 vector를 사용한다
* 프로그램에 크기가 작은 요소가 많고 공간에 대한 부담이 중요하다면 list나 forward_list는 사용하지 않는다
* 프로그램에서 인덱스로 요소를 접근해야 한다면 vector나 deque를 사용한다
* 프로그램에서 컨테이너 가운데에 요소를 삽입하거나 삭제해야 하면 list나 forward_list를 사용한다
* 프로그램에서 처음과 끝에서만 요소를 삽입하거나 삭제하고 가운데에서는 하지 않는다면 deque를 사용한다.
* 프로그램에서 입력을 읽는 동안에만 컨테이너 가운데에 요소를 삽입하고 그 이후에는 요소에 임의 접근해야 한다면
  * 먼저 실제로 컨테이너 가운데에 요소를 추가해야 하는지 결정한다. 입력을 마쳤을 때 컨테이너 내용을 재정렬하기 위해 vector에 추가한 다음 sort 함수를 호출하는 것이 더 쉽다
  * 반드시 가운데에 삽입해야 하면 입력하는 동안에는 list사용을 고려한다. 입력을 마치면 list를 복사해 vector에 넣는다

#### 헤더

일반적으로 각 컨테이너는 해당 타입과 같은 이름인 헤더 파일에 정의한다. deque는 deque 헤더, list는 list 헤더에 정의하는 식이다. 

#### 순차 컨테이너 생성

컨테이너종류 <타입> 이름 순으로 선언, 크기와 요소 값으로 초기화 할 수도 있다.

```c++
vector <const char*> articles = {"a", "an", "the"};
list<string> authors = {"Milton","Shakespeare","Austen"};
list<int> num; //빈 공간도 가능
array<int,42> ia1 // int를 42개 담는 array, 기본 초기화
//크기와 요소 초기값으로 초기화 할 수도 있다.
vector<int> ivec(10,-1); //int 요소 10개, 각각은 -1로 초기화한다.
forward_list<int> ivec(10); //int 요소 10개, 각각은 0으로 기본 초기화한다.
```

#### 반복자

반복자는 순차, 연관 컨테이너 위치를 나타내는 변수의 일종이다.

반복자는 const_iterator와 그냥 iterator가 있다. 컨테이너가 const이면 반복자도 const적용되고 const가 아니면 반복자의 const에 따른다

```c++
list<string> a = {"Milton","Shakespeare","Austen"};

list<string>::iterator it5; //it5는 list<string>타입의 반복자이다.
list<string>::iterator it6 = a.begin(); //list a의 시작점을 반환한다.
auto it7 = a.cend(); //auto를 사용해도 된다
```

#### 대입/swap

컨테이너의 종류와 요소 타입이 같으면 대입이 가능하다.

```c++
c1 = c2; //c1 내용을 c2 요소로 복사한다.
list<string> list2 (authors); //authors는 list2와 컨테이너 종류와 요소 타입이 같다.
```

##### assign

assign은 컨테이너의 두 요소의 타입이 달라도 변환이 가능하면 복사가 가능하다.

```c++
list<string> names;
vector<const char*> oldstyle;
names = oldstyle; //오류 : 컨테이너 타입이 일치하지 않는다
names.assign(oldstyle.cbegin(), oldstyle.cend()); //타입이 변환 가능하므로 복사, 단 반복자 두개로 범위를 지정해야 함
```



swap는 두 컨테이너의 요소를 교체하는 것이다. 교체는 요소를 복사하는 것보다 훨씬 더 빠르다(상수 시간 보장)

```c++
vector<int> c1(10); //요소가 10개인 vector
vector<int> c2(24); //요소가 24개인 vector
swap(c1,c2); //이걸 주로 사용하는걸 추천
c1.swap(c2); //이 방식도 가능
```

#### 크기/상등,관계연산자

size( )함수는 요소의 개수를 반환한다.

empty( )함수는 크기가 0이면 true, 크기가 1이면 false를 반환한다. forward_list에서는 지원하지 않는다

Max_size는 해당 타입 컨테이너에서 담을 수 있는 요소 수보다 크거나 같은 수를 반환한다.

```c++
bool tof = c1.empty();
```

상등연산자(==, !=)와 관계연산자(>,<,>=,<=)도 지원한다. 단, 반드시 컨테이너 타입과 요소 타입이 같아야 한다. 그리고 클래스 객체가 요소인 경우 객체끼리 연산이 정의 돼있어야 가능하다.

#### 요소 추가

* push_back( )은 array와 forward_list를 제외한 모든 순차 컨테이너에서 끝에 요소를 추가한다. size가 1 증가한다.

  ```c++
  vector<string> container;
  string word = "hi";
  container.push_back(word);
  ```

* push_front( )는 list, forward_list,deque 컨테이너에서 처음에 새 요소를 추가한다.

  ```c++
  list<int> ilist; 
    ilist.push_front("aa");
  ```

* insert( )는 원소 0개 이상을 컨테이너 내 어느 위치든 추가할 수 있다. 반복자로 나타내는 위치 앞에 요소를 삽입한다. vector, deque, list, string에서 지원하고 forward_list에서는 이 멤버의 특수화 버전을 제공한다. 

  ```c++
  slist.insert(iter, "Hello!"); //iter 바로 앞에 "Hello!"를 삽입한다.
  slite.insert(iter,10,1); //반복자 iter앞에 값이 1인 요소를 10개 추가한다.
  slite.insert(iter1,iter2,iter3); //반복자 iter1로 나타내는 요소 앞에 반복자 iter2와 iter3로 나타내는 범위의 요소를 참조하는 반복자를 반환한다.
  slite.insert(iter,{0,1,2,3,4}); //iter 앞에 중괄호로 둘러싼 값을 삽입한다.
  ```

#### 요소 삭제



#### 반복자 얻기



# 딕셔너리(연관 컨테이너)








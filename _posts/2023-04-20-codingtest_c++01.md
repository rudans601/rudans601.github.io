---
layout: single
title: "C++/python 자료구조 -리스트와 딕셔너리(순차 컨테이너와 연관 컨테이너)"
categories: codingtest_C++/python
tags: [c++,python,codingtjest]
author_profile: false
#search: false
---

# 리스트(순차 컨테이너)

## list() - 파이썬

### 요약

파이썬에선 리스트를 사용하면 스택을 사용할지, 큐를 사용할지 고민하지 않아도 되며, 스택과 큐에 사용 가능한 모든 연산을 함께 제공한다.

|      연산      | 시간 복잡도 |                             설명                             |
| :------------: | :---------: | :----------------------------------------------------------: |
|     len(a)     |    O(1)     |                 전체 요소의 개수를 리턴한다                  |
|      a[i]      |    O(1)     |                  인덱스 i의 요소를 가져온다                  |
|     a[i:j]     |    O(k)     | 인덱스 i부터 j-1까지 슬라이스의 길이만큼인 k개의 요소를 가죠온다. 이 경우 객체 k개에 대한 조회가 필요하므로 O(k)이다 |
|   elem in a    |    O(n)     | elem 요소가 존재하는지 확인한다. 처음부터 순차 탐색하므로 n만큼 시간이 소요된다 |
| a.count(elem)  |    O(n)     |                  elem요소의 개수를 리턴한다                  |
| a.index(elem)  |    O(n)     |                 elem요소의 인덱스를 리턴한다                 |
| a.append(elem) |    O(1)     |             리스트 마지막에 elem요소를 추가한다              |
|    a.pop()     |    O(1)     |        리스트 마지막 요소를 추출한다. 스택의 연산이다        |
|    a.pop(0)    |    O(n)     | 리스트 첫번째 요소를 추출한다. 큐의 연산이다. 이 경우 전체 복사가 필요하므로 O(n)이다. 나중에 다시 살펴보겠지만 큐의 연산을 주로 사용한다면 리스트보다는 O(1)이 가능한 데크를 권장한다. |
|    del a[i]    |    O(n)     |            i에 따라 다르다. 최악의 경우 O(n)이다.            |
|   a.sort( )    | O(n log n)  | 정렬한다. 팀소트를 사용하며 최선의 경우에도 O(n)에도 실행될 수 있다. |
| min(a), max(a) |    O(n)     | 최솟값/최댓값을 계산하기 위해서는 전체를 선형 탐색해야 한다. |
|  a.reverse( )  |    O(n)     | 뒤집는다. 리스트는 입력 순서가 유지되므로 뒤집게 되면 입력 순서가 반대로 된다. |

### 사용 방법

#### 리스트 선언

```python
a = list() #기본 선언방식
a = [ ] #간단하게
a = [1,2,3] #초기값을 지정해 선언 가능, 요소끼리 다른 자료형도 추가 가능
```

#### 리스트 요소 추가

* append( )

  리스트의 제일 뒤에 요소 추가

  ```py
  a.append(4) #[1,2,3,4]
  ```

* insert( )

  특정 위치의 인덱스를 지정해 요소 추가

  ```py
  a.insert(3,5) #3번째 인덱스에 5를 추가 -> [1,2,3,5,4]
  ```

#### 리스트 요소 찾기(슬라이싱)

파이썬 인덱스는 0부터 시작

```python
#a = [1,2,3,5,4]
a[3] #5 반환
a[1:3] #인덱스 1부터 3 이전까지 -> [2,3] 반환
a[:3] #처음부터 3 이전까지 -> [1,2,3] 반환
a[4:] #인덱스 4부터 마지막까지 -> 5 반환
a[1:4:2] #세번째 파라미터는 몇 칸씩 건너뛸지 여부이다 -> [2,5] 반환
```

#### 리스트 요소 삭제

* del

  특정 위치의 인덱스로 삭제하기

  ```py
  a = [1,2,3,5,4]
  del a[1] #인덱스 1에 있는 2 삭제 -> [1,3,5,4]
  ```

* remove( )

  값으로 삭제하기

  ```py
  a.remove(3) #값이 3인 요소 삭제 -> [1,5,4]
  ```

* pop( )

  스택의 팝 연산과 비슷하다. 인덱스를 작성하지 않으면 가장 마지막 요소를 반환 후 삭제하고, 인덱스를 작성하면 그 인덱스 값을 리턴하고 삭제된다.

  ```py
  a = [1,2,3,5,4]
  a.pop() #마지막 인덱스를 반환하고 삭제 -> 4 반환 후 [1,2,3,5]
  a.pop(3) #인덱스 3을 반환하고 삭제 -> 5 반환 후 [1,2,3]
  ```

  

## 순차컨테이너-c++

### 요약

#### 순차 컨테이너 종류

* vector

  가변 크기 배열

  장점 : 빠른 접근 지원(인덱스)

  단점 : 끝 이외에서 요소를 삽입하거나 삭제하면 느려짐

* deque

  끝이 양쪽인 큐

  장점 : 빠른 접근 지원(인덱스), 처음 또는 끝에서 삽입/삭제가 빠르다

  단점 : 가운데에 요소를 추가하거나 이동하면 느려짐

* list

  이중 연결 리스트

  장점 : 모든 지점에서 삽입/삭제가 빠르다

  단점 : 양방향 순차 접근만 지원함

* forward_list

  단일 연결 리스트

  장점 : 모든 지점에서 삽입/삭제가 빠르다

  단점 : 단방향 순차 접근만 지원함, size연산이 없다

* array

  고정 크기 배열

  장점 : 빠른 접근 지원(인덱스), 내장 배열보다 안전하고 사용하기 쉬움

  단점 : 요소를 추가하거나 제거할 수 없다, 배열 크기를 변경할 수 없음

* string

  문자를 담는 특별한 컨테이너, vector와 비슷

  장점 : 빠른 접근 지원(인덱스), 끝에서 삽입 삭제 빠름

  단점 : 끝 이외에서 요소를 삽입하거나 삭제하면 느려짐



### 사용 방법

#### 사용할 순차 컨테이너 결정하기

사용할 컨테이너를 선택할 때 다음 원칙을 고려해볼 수 있다.

* 다른 컨테이너를 사용할 이유가 없으면 vector를 사용한다
* 프로그램에 크기가 작은 요소가 많고 공간에 대한 부담이 중요하다면 list나 forward_list는 사용하지 않는다
* 프로그램에서 인덱스로 요소를 접근해야 한다면 vector나 deque를 사용한다
* 프로그램에서 컨테이너 가운데에 요소를 삽입하거나 삭제해야 하면 list나 forward_list를 사용한다
* 프로그램에서 처음과 끝에서만 요소를 삽입하거나 삭제하고 가운데에서는 하지 않는다면 deque를 사용한다.
* 프로그램에서 입력을 읽는 동안에만 컨테이너 가운데에 요소를 삽입하고 그 이후에는 요소에 임의 접근해야 한다면
  * 먼저 실제로 컨테이너 가운데에 요소를 추가해야 하는지 결정한다. 입력을 마쳤을 때 컨테이너 내용을 재정렬하기 위해 vector에 추가한 다음 sort 함수를 호출하는 것이 더 쉽다
  * 반드시 가운데에 삽입해야 하면 입력하는 동안에는 list사용을 고려한다. 입력을 마치면 list를 복사해 vector에 넣는다

#### 헤더

일반적으로 각 컨테이너는 해당 타입과 같은 이름인 헤더 파일에 정의한다. deque는 deque 헤더, list는 list 헤더에 정의하는 식이다. 

# 딕셔너리(연관 컨테이너)








---
layout: single
title: "C++ primer 03"
categories: C++_primer
tags: [c++]
toc: true
author_profile: false
sidebar:
  nav: "docs"
#search: false
---

#### 연습문제 2.9

(a) std::cin >> int input_value; 는 올바르지 않다. 선언을 먼저 하고 표준 입력으로 받아야 하기 때문이다. 고친다면

int input_value;

std::cin >> input_value;

로 수정해야 한다.

(b)int i = {3.14}; 올바르지 않다. 초기값 때문에 값의 손실이 온다면 초기화 목록 사용을 허용하지 않기 때문이다.

double i = {3.14};

로 수정해야 한다.

(c) double salary = wage = 9999.99; 올바르지 않다. wage를 선언을 하고 사용해야 하는데 그러지 못했다

double salary, wage;

double salary = wage = 9999.99;

로 수정해야 한다.

(d) int i = 3.14 올바르다.

#### 연습문제 2.10

```c++
std::string global_str; //빈 문자열로 초기화
int global_int; //0으로 초기화
int main()
{
    int local_int; //없음
    std::string local_str; //빈 문자열로 초기화
}
```

## 변수 선언과 정의

변수 선언은 변수의 이름을 프로그램에 알리는 것으로, 어딘가에서 정의한 이름을 사용하려면 그 이름에 대한 선언을 포함한다.

정의는 연관된 개체를 만든다.

변수 선언에서는 변수 타입과 이름을 지정한다. 변수 정의는 곧 선언이며, 이름과 타입을 지정하는 것에 추가로 저장공간을 할당하고 초기 값을 지정할 수도 있다.

정의가 아닌 선언을 할려면 extern 키워드를 사용하면 되는데 명시적인 초기값은 지정하지 않아야 한다.

```c++
extern int i; //선언 했지만 정의하진 않는다
int j; //선언하면서 정의한다.
extern double pi = 3.1416; //정의, extern 무시
```

선언과 정의를 구별하는 것이 지금은 명확하지 않을 수 있지만 정말 중요하다. 변수를 여러 파일에서 쓰려면 정의와는 별도로 선언을 해야 한다. 같은 변수를 여러 파일에서 쓰려면 그 변수를 오직 한 파일에서만 정의하고, 다른 파일에서는 그 변수에 대한 정의가 아닌 선언을 해야한다.

#### 연습 문제 2.11

```c++
extern int ix = 1024; //정의
int iy; //선언 과 정의
extern int iz; //선언
```

## 식별자

식별자는 내가 사용할려는 변수나 함수 이름이다.

식별자는 예약어와 같은 이름으로 짓지 못하고 식별자는 문자나 밑줄 문자로 시작해야 한다.

변수 이름 규칙

- 식별자는 그 자체로 의미를 나타내야 한다.
- 변수 이름은 보통 소문자로 쓴다
- 클래스는 보통 대문자로 시작한다.
- 식별자가 여러 단어일 경우 student_loan 이나 studentLoan 처럼 구분 되도록 한다.

#### 연습 문제 2.12

```c++
int double = 3.14; //유효하지 않다. double은 예약어이다.
int _; //유효하지만 함수 밖에서 정의하면 유효하지 않다.
int catch-22; //유효하지 않다. 예약어와 - 특수문자는 사용할 수 없다.
int 1_or_2 = 1; //유효하지 않다. 식별자는 숫자로 시작하지 않는다.
double Double = 3.14; //유효하다. 대문자로 예약어를 피해갔기 때문이다.
```

## 이름 유효 범위

유효 범위는 프로그램에서 이름이 특별한 의미를 지니는 구역이며 대부분의 유효 범위는 중괄호로 구분한다. 같은 이름이라도 유효 범위가 다르면 다른 개체를 참조할 수 있다.

전역 변수와 지역변수 이름이 같고 "::변수이름" 을 사용하면 전역 변수를 가리킨다.

#### 연습 문제 2.13

```c++
int i = 42;
int main()
{
    int i = 100;
    int j = i;
}
```

j값은 100이다.

#### 연습 문제 2.14

```c++
int i = 100, sum = 0;
for(int i = 0;i != 10; ++i)
{
    sum += i;
    std::cout << i << " " << sum << std::endl;
}
```

올바르다. 출력값은 0 0,1 1,2 3,4 10,5 15,6 21,7 28,8 36,9 45 이다.

## 복합 타입

복합 타입은 다른 타입을 사용해 정의한 타입이다. 일단 이 단원에서는 두가지만 다룬다.

- 참조자
- 포인터

### 참조자

참조자는 객체(변수, 함수)의 별칭(별명)이라고 생각하면 편하다. 참조자는 이름 앞에 &붙인다.

```c++
int ival = 1024;
int &refVal = ival; //refVal은 변수 ival을 참조한다. ival의 별명이다.
int &refVal2; //오류 : 참조자는 초기화해야 한다.
```

참조자는 객체가 아니며, 이미 존재하고 있는 객체에 대한 다른 이름일 뿐이다.

참조자가 정의 되고 난 뒤 해당 참조자에 대한 모든 연산은 그 참조자가 참조하고 있는 객체에 대한 연산이다.

```c++
refVal = 2; //ival도 2로 변경 된다.

int ii = refVal; //ii는 ival과 같다.
```

참조자에 대입 하면 해당 참조자가 참조하는 객체에 대입한다. 참조자 값을 가져오면 실제로는 참조자와 결합한 객체의 값을 가져온다. 마찬가지로 참조자를 초기화식으로 사용하면 실제로는 참조자와 결합한 객체를 사용한다.

```c++
int &refVal3 = refVal; //좋음: refVal3는 refVal과 결합한 객체인 ival과 결합한다.
// refVal과 결합한 객체의 값으로 i를 초기화 한다.
int i = refVal; //좋음 : ival과 같은 값으로 i를 초기화한다. 1024
```

참조자는 객체가 아니므로 참조자에 대한 참조자는 정의할 수 없다.

### 참조자 정의

한줄에 여러 참조자를 정의할 수 있다.

```c++
int i = 1024, i2 = 2048; //i와 i2는 모두 int이다
int &r = i, r2 = i2; //r은 i와 결합한 참조자 이고 r2는 int이다
int i3 = 1024, &ri = i3; //i3는 int이고 ri는 i3와 결합한 참조자이다
int &r3 = i3, &r4 = i2; //r3와 r4는 참조자이다
```

참조자 타입과 참조자가 참조하는 객체의 타입은 정확히 일치 해야 한다.

참조자는 객체와 결합 할 수 있으며 상수나 일반적인 표현식 결과와는 결합할 수 없다.

```c++
int &refVal4 = 10; //오류: 초기값은 객체여야 한다.
double dval = 3.14;
int &refVal5 = dval; //오류 : dval객체가 int여야 한다.
```

#### 연습 문제 2.15

```c++
int ival = 1.01;
int &rval1 = 1.01; //참조자가 참조하는 객체는 상수는 안된다.
int &rval2 = ival;
int &rval3; //참조자가 어떤 객체를 참조하는지 모르기 때문에 안된다.
```

#### 연습 문제 2.16

```c++
int i = 0, &r1 = i;
double d = 0, &r2 = d;
r2 = 3.14159; //올바르다, d = 3.14159를 대입한다.
r2 = r1; //d = i 이다. 값은 0.0
i = r2; //i = d이다. 값은 0
r1 = d; //i = d이다. 값은 0
```

#### 연습 문제 2.17

```c++
int i, &r1 = i;
i = 5, r1 = 10;
std::cout << i << " " << ri << std::endl;
```

10 10이 출력 된다.

## 포인터

포인터는 다른 타입을 가리키는 복합 타입이다. 포인터는 참조자처럼 다른 타입에 간접적으로 접근하는데 사용 되는데 포인터는 참조자와 달리 그 자체로 객체이다.

포인터는 대입하거나 복사할 수 있으며 포인터 하나가 생명 주기 동안 여러 다른 객체를 가리킬 수 있다.

포인터는 참조자와 달리 정의할 때 초기화를 하지 않아도 된다.

포인터는 "타입 *포인터변수명" 이렇게 쓴다. *은 각 포인터 변수마다 반복해 써야 한다.

```c++
int *ip1, *ip2;
double dp, *dp2;
```

### 객체 주소 얻기

포인터는 다른 객체의 주소를 담고 있다. 객체의 주소는 주소 연산자(&)를 사용해 얻는다.

```C++
int ival = 42;
int *p = &ival; //p는 ival의 주소를 담고 있고 p는 ival의 포인터이다.
```

참조자는 객체가 아니므로 주소가 없다. 따라서 참조자에 대한 포인터는 정의할 수 없다.

포인터 타입과 그 포인터가 가리키는 객체의 타입은 일치해야 한다.

```c++
double dval;
double *pd = &dval; //좋음 : 초기값은 double타입이다
double *pd2 = pd; //좋음 : 초기값은 double에 대한 포인터이다
int *pi = pd; //오류: pi와 pd는 타입이 서로 다르다
pi = &dval; //오류 : double 변수 주소를 int 포인터에 넣을려 한다
```

### 포인터 값

포인터에서 저장하는 값인 주소는 다음 4가지 상태 중 하나가 될 수 있다.

- 객체를 가리킬 수 있다.
- 객체의 마지막 요소 바로 다음 위치를 가리킬 수 있다.
- 어느 객체와도 결합하지 않았음을 나타내는 널 포인터일 수 있다.
- 유효하지 않을 수 있다. 즉 먼저 본 세 가지 경우 외 다른 값일 수 있다.

유효하지 않은 포인터 값을 복사하거나 접근하는 것은 오류이다.

### 포인터를 이용해 객체에 접근하기

포인터로 객체를 가리키고 있으면 역참조 연산자(\*)를 사용해 객체에 접근할 수 있다.

```c++
int ival = 42;
int *p = &ival; //p는 ival의 주소를 담고 있는, ival에 대한 포인터이다.
cout << *p; //*은 p로 가리키는 객체를 반환하므로 42를 출력한다.

*p = 0; //*는 객체를 반환하므로 p를 통해 ival에 새로운 값을 대입한다.
cout << *p; //0을 출력
```

### 널 포인터

널 포인터는 어느 객체도 가리키지 않으므로 포인터를 사용하기 전에 널인지 확인 하는 것이 좋다. 널 포인터로 만드는 몇가지 방법은 다음과 같다.

```c++
int *p1 = nullptr; // int *p1 = 0;과 같다
int *p2 = 0; // p2를 상수 0으로 직접 초기화한다.
//#include를 사용해 cstdlib를 포함 해야 한다.
int *p3 = NULL; // int *p3 = 0;과 같다
```

포인터를 초기화하는 가장 직접적인 방법은 새로운 표준에서 추가한 nullptr 상수를 사용하는 것이다.

모든 포인터는 초기화 한다.

### 대입과 포인터

포인터와 참조자는 비슷하지만, 참조자는 한번 정의하면 다른 객체를 참조할 수 없다. 참조자를 사용하면 항상 그 참조자와 처음 결합한 객체를 얻는다.

포인터는 다른 변수처럼 다른 주소를 대입할 수 있다. 대입을 하면 포인터는 다른 객체를 가리킨다.

```c++
int i = 42;
int *pi = 0; //pi를 초기화 하지만 다른 객체 가리키지 않음(null 포인터)
int *pi2 = &i; //pi2를 i주소로 초기화
int *pi3; //pi3를 구역 안에서 정의하면 초기화 하지 않는다.
pi3 = pi2; //pi3와 pi2는 같은 객체 i를 가리킴
pi2 = 0; //pi2는 아무 객체도 가리키지 않는다(null 포인터)
```

### 다른 포인터 연산

포인터 값이 유효하면 조건에도 쓸 수 있다. 조건에서 산술 값을 사용할 때처럼 포인터가 0이면 조건은 false가 된다.

```c++
int ival = 1024;
int *pi = 0; //pi는 유효하며 널포인터
int *pi2 = &ival; //pi2는 ival의 주소를 담고 있는 포인터
if(pi) //false
{
    //...
}
if(pi2) //true
{
    //...
}
```

두 포인터를 비교할 때 상등 연산자(==), 부등 연산자(!=)로 비교가 가능하며 주소값이 같으면 상등 연산자는 참이고, 주소값이 다르면 부등 연산자가 참이다.

### void\* 포인터

void\* 타입은 모든 객체의 주소를 담을 수 있는 특별한 포인터 타입이다. 하지만 가리키는 객체의 타입은 알 수 없다.

```c++
double obj = 3.14; *pd = &obj;
void *pv = &obj; //obj는 어떤 타입의 객체라도 될 수 있다.
pv = pd;//pv는 어떤 타입의 포인터라도 담을 수 있다.
```

void\*를 사용해 이 타입으로 가리키는 객체에 연산할 수는 없다.(역참조 연산자 이용 불가능?)

#### 연습 문제 2.18

```c++
int a = 0, c = 1;
int *b = &a;
b = &c; //포인터 값을 변경
*b = 15; //포인터로 가리키는 값 변경
```

#### 연습 문제 2.19

포인터는 객체이고 참조자는 객체가 아니다. 참조자는 한번 정의하면 다른 객체를 참조할 수 없다. 하지만 포인터는 한번 정의해도 다른 포인터나 주소 값을 대입 해 다른 객체를 참조할 수 있다.

#### 연습 문제 2.20

42 \* 42 값을 i에다가 대입한다.

#### 연습 문제 2.21

```c++
int i = 0;
double* dp = &i; //double형 포인터 dp에 int형 변수 i의 주소를 저장한다.
//올바르지 않다. 가리키는 객체의 타입이 같지 않기 때문이다.
int *ip = i; //int형 포인터 ip에 int형 변수 i의 주소를 저장한다.
/*올바르지 않다. 포인터 변수에 주소 말고 정수를 저장하려고 하기 때문이다. 0이라도 안된다.*/
int *p = &i; //int형 포인터 p에 int형 변수 i의 주소를 저장한다.
```

#### 연습 문제 2.22

```c++
if (p) //p의 주소가 null이 아니면 true이고 null이면 false이다.
if (*p) //p가 가리키는 객체가 0이 아니면 true이고 0이면 false이다.
```

#### 연습 문제 2.23

포인터 p가 초기화 됐을 때, 유효한 객체를 가리키고 있는지 결정할 수 있다. 포인터가 초기화가 된다면, null을 가리키거나 정상적인 다른 객체를 가리키게 되기 때문이다.

#### 연습 문제 2.24

p는 void평 포인터라서 가리키는 객체가 어떤 타입이든 주소를 담을 수 있지만 lp는 long형 포인터인데 int형 변수 i를 가리킬려고 해서 옳지 않다.

### 포인터에 대한 포인터

포인터는 메모리에 있는 객체 이므로 다른 객체처럼 주소가 있다. 그러므로 포인터의 주소를 다른 포인터에 저장할 수 있다.

```c++
int ival = 1024;
int *pi = &ival; //pi는 int형 변수 ival을 가리킨다.
int **ppi = &pi; //ppi는 int형 포인터 변수 pi를 가리킨다.
```

포인터에 대한 포인터는 역 참조하면 포인터를 반환한다. 따라서 포인터에 대한 포인터가 가리키는 객체에 접근할려면 원래 포인터를 두 번 역 참조 해야 한다.

### 포인터에 대한 참조자

참조자는 객체가 아니므로 참조자에 대한 포인터는 없다. 하지만 포인터는 객체이므로 포인터에 대한 참조자는 정의할 수 있다.

```c++
int i = 42;
int *p; //p는 int에 대한 포인터이다.
int *&r = p; //r은 포인터 p에 대한 참조자이다.
r = &i; //r은 포인터를 참조하므로 &i를 r에 대입하면 p는 i를 가리킨다.
*r = 0; //r을 역참조하면 p로 가리키는 객체 i를 반환하므로 i를 0으로 변경한다.
```

r의 타입을 이해하는 가장 쉬운 방법은 정의를 오른쪽에서 왼쪽으로 읽는 것이다. 변수 이름에 가장 가까운 기호(&r에 있는 &)는 변수 타입에 가장 즉각적인 효과를 나타낸다. 즉 r은 참조자이다. 나머지는 r이 참조하는 타입을 결정하다. 다음 기호는 \*이며, r이 참조하는 타입이 int형 포인터 타입이라는 걸 알려준다.

#### 연습 문제 2.25

```c++
int * ip, i, &r = i; //ip와 i는 int형 포인터 값은 미정의, r은 int형 포인터에 대한 참조자이다. int형 포인터 i를 참조한다. 하지만 미정의 이므로 r도 미정의
int i, *ip = 0; //i는 int형 변수이고, ip는 int형 포인터이다. null포인터로 정의됐다.
int* ip, ip2; //ip와 ip2는 모두 int형 포인터이다. 값은 미정의
```

# const 한정자

변수 값을 바꿀 수 없도록 정의하고 싶을 때, 변수 타입을 const로 정의해 바뀌지 않도록 할 수 있다. 상수라고 생각하면 된다.

```c++
const int bufSize = 512;
```

이제 이 변수에 다른 값을 대입하면 오류가 발생한다.

const 변수를 생성한 후에는 값을 바꿀 수 없기 때문에 반드시 초기화 해야 한다.

```c++
const int i = get_size(); //좋음 : 실행 중 초기화 했다.
const int j = 42; //좋음 : 컴파일 중 초기화 했다.
const int k; //오류 : k는 미초기화 const
```

### 초기화와 const

const타입은 해당 타입의const가 아닌 버전에서 제공하는 연산 중에 모두가 아닌 대부분을 사용할 수 없다. 한가지 제약은 객체를 바꿀수 없는 연산만 사용할 수 있다.

초기화도 객체의 값을 변경하지 않는 연산이므로, 객체를 사용해 다른 객체를 초기화할 때는 둘 모두 또는 그 중 어느 쪽이 const인지는 중요하지 않다.

```c++
int i = 42;
const int ci = i; //좋음 : i값을 ci로 복사한다.
int j = ci; //좋음 : ci값을 j로 복사한다.
```

ci이 처음 초기화 됐을 땐 우변에 i 변수가 와서 초기화 되는 건 허용이다. 하지만 이후 값을 대입 하려 하면 오류가 발생한다.

ci가 const int라도 ci 값은 int 이다. ci의 const 성질은 ci를 변경할 수 있는 연산에서만 중요하다. ci를 복사해 j를 초기화할 때, ci가 const인지는 중요하지 않다. 객체를 복사하는 행위는 그 객체를 변경하지 않으며, 복사를 한 후 새 객체는 더 이상 원래 객체에 접근하지 않는다.

### 기본적으로 const 객체는 파일에 지역적이다.

const객체를 여러 파일에서 공유할려면 그 변수를 extern으로 정의해야 한다.

```c++
//file_1.cc
extern const int bufSize = fcn();
//file_1.h
extern const int bufSize;
```

#### 연습 문제2.26

```c++
const int buf; //초기화를 하지 않았으므로 옳지 않다
int cnt = 0; //옳다
const int sz = cnt; //옳다
++cnt;++sz; //++sz는 옳지 않다.
```

## const에 대한 참조자

다른 객체와 마찬가지로 참조자를 const타입 객체에 결합할 수 있다. const에 대한 참조자를 사용하는데, 이는 const타입을 참조하는 참조자이다. 보통의 참조자와는 달리 const에 대한 참조자를 사용해 해당 참조자와 결합한 객체를 바꿀 수 없다.

```c++
const int ci = 1024;
const int &r1 = ci; //좋음 : 참조자와 대상 객체 모두 const이다.
r1 = 42; //오류 : r1은 const에 대한 참조자 이다.
int &r2 = ci; //오류 : const 객체에 const가 아닌 참조자를 사용했다. const인 참조자를 사용해야 한다.
```

ci에 직접 대입할 수 없으므로 참조자를 사용해 ci를 바꾸는 것도 할 수 없어야 한다.(int &참조자는 값을 변경할 수 있으니까 대입이 가능하므로 막아놓은거다 )그러므로 r2초기화는 오류.

50~69p 완료!

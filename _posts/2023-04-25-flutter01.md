---
layout: single
title: "플러터 노트01"
categories: flutter
tags: [flutter]
author_profile: false
#search: false

---

# flutter 정리

## flutter VSC code action

vscode의 코드 액션을 간단하게 설명

* Wrap with ~

  ~로 감싸준다

* Wrap with widget

  커스텀 위젯으로 감싸준다 이름은 내가 지정하기

* Remove this ~

  ~를 제거해줌

* Extract Widget

  드래그 한 부분을 위젯으로 내보낸다. 위젯 이름 지정

  위젯을 만들면 밑에 위젯이 만들어지는데 이 위젯을 기능별로 폴더와 파일을 만들어서 붙혀넣기 하고 임포트 하는게 나중에 유지보수 하기에 더 좋다.

  ```dart
  import 'package:flutter/material.dart'; //import를 컴파일러가 추천해서 자동 작성하거나 아니면 내가 작성
  
  class MyWidget extends StatelessWidget { //st를 입력하면 손쉽게 작성 가능, 보통은 stateless로 작성
    final String text; //전달 받고 싶은 인자를 만들어줌 1
    final Color bgColor; //전달 받고 싶은 인자를 만들어줌 2
    final int num1; //전달 받고 싶은 인자를 만들어줌 3
    final _blackColor = const Color(0xFF1F2123); //변수 앞에 _언더바는 private 접근지정자이다.
    
    const MyWidget({ //코드액션으로 final 필드(아래의 생성자 형식)를 만들수 있음
      super.key,
      required this.text, //생성자 안에 required를 써서 인스턴스 작성
      required this.bgColor,
      required this.textColor,
    }); 
  
    @override
    Widget build(BuildContext context) {
      return //내가 만들려는 위젯 붙여넣고 위의 클래스 인자(변수)를 넣어주기;
    }
  }
  ```

  Button 위젯을 만들고 다른 클래스에서 사용할려면

  ```dart
  Button(
    text: 'transfer',
    bgColor: color,
    textColor: Colors.black,
  ),//안에 클래스 인자들을 작성해주면 된다.
  ```

  

* Move widget ~

  위젯을 위나 아래로 움직인다

## 기본구조

```dart
void main()
{
  //App의 ui를 실행하기 전에 백엔드 함수 등등을 만들어서 먼저 실행시킬 수 있다
  runApp(App());
}

class App extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(); //CupertinoApp : ios스타일, MaterialApp() : Android 스타일
  }
}
```

## MaterialApp( ), Scaffold( )

MaterialApp()은 Android 스타일 앱을 만들게 해줌. 테마를 적용할 수 있음

Scaffold()는 모바일 앱의 모든화면에 필요하다. 네비게이션바, 텍스트, 위젯, 박스등등..

* MeterialApp()

  * theme:

    테마 지정

    * TextTheme()

      텍스트의 테마 지정

      * titleLarge: 

        타이틀 크기?

        * TextStyle()

          아래 Text() 참고

  * Scaffold()
  
    * body

      메인이 되는 프로퍼티이다.

      * Center( ) 

        괄호안에 있는 걸 중앙정렬 해줌

      * Column( )
  
        * children[ ]
  
      * Row( )
  
        * children[ ]
        
      * Padding( )
  
    * appBar :
  
      appBar 프로퍼티는 위젯의 일종으로 앱의 상단바를 만들어준다.
  
      * AppBar( )
  
        * title:
    
          title은 제목
    
          * Text( )
    
        * backgroundColor: 
    
          앱바의 색상을 지정
    
        * foregroundColor:
    
          앱바의 텍스트 색상 지정
    
        * elevation:
    
          앱바의 그림자 조정(0부터 ~까지)
    
    * backgroundColor 
    
      배경 색상을 지정한다. 



```dart
void main()
{
  runApp(App());
}

class App extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp( //home 프로퍼티는 가장 메인이 되는 프로퍼티
      appBar: AppBar(
      	title: Text('hello flutter!'),),
      home: Scaffold( //Scaffold의 body는 가장 기본이 되는 프로퍼티
      body: Center(Text('Hello world'),),), 
    ); 
  }
}
```

## Text( )

* Text()

  * style :

    스타일 프로퍼티

    * TextStyle()

      텍스트 스타일 설정 프로퍼티

      * color:

        색상 설정 프로퍼티
        
        * colors.white
        
          색상
        
          * .withOpacity(1)
        
            투명도 0~1
      
      * fontSize: 숫자
      
        폰트 크기
      
      * fontWeight:
      
        폰트 굵기
      
        * FontWeight.w600
      
          숫자가 클수록 굵음
      
        
      
        

```dart
Text('Hello world') //추가 프로퍼티는 쉼표(,)추가하고 플러터 참고
```

## Center( )

```dart
Center(
  child: Text('Hello world'),) //괄호 안에 있는 걸 중앙정렬 해줌, 여러개 넣을려면 쉼표 추가 후 넣기
```

* Center( )
  * child:

## Colors

색상 프로퍼티다. 색상을 표현하는 방법은 여러가지가 있는데

```dart
backgroundColor: Colors.blue; //.shade는 색조다. 숫자로 조정0~900
backgroundColor: Color(0xFF181818), 
backgroundColor: Color.fromARGB(255,145,36,36); //R G B opacity
```

## Column()

수직배열을 만들어낸다. 상자가 아래로 쌓여있는 형태

| 1    |
| ---- |
| 2    |
| 3    |
| 4    |

* Column()

  * mainAxisAlignment : 

    정렬이다. column은 수직방향이므로 수직이 main이다

    * MainAxisAlignment.end

      .center는 가운데 정렬, .end는 오른쪽 정렬, 나머지는 플러터 참고

  * crossAxisAlignment :

    수직의 수직방향으로 정렬이다. 즉, 수평방향으로 정렬한다

    * crossAxisAlignment.end

      .center는 가운데 정렬, .end는 아래로 정렬, 나머지는 플러터 참고

  * children[ ]
  
    자식들을 [ ]대괄호 안에 넣어서 정렬할 수 있다.

## Row()

수평배열을 만들어낸다. 상자가 오른쪽으로 쌓여있는 형태

|  1   |  2   |  3   |  4   |
| :--: | :--: | :--: | :--: |

* Row( )
  
  * mainAxisAlignment :
  
    정렬이다. Row는 수평방향이므로 수평이 main이다
  
    * MainAxisAlignment.end
  
      .center는 가운데 정렬, .end는 아래로 정렬, 나머지는 플러터 참고
      
      .spaceBetween는 서로 간격을 주는 기능이다.
  
  * crossAxisAlignment :
  
    수평의 수직방향으로 정렬이다. 즉 수직 방향으로 정렬한다.
  
    * crossAxisAlignment.end
  
      .center는 가운데 정렬, .end는 오른쪽 정렬, 나머지는 플러터 참고
  
  * children[ ]
  
    자식들을 [ ]대괄호 안에 넣어서 정렬할 수 있다.
  
    

## SizedBox( )

그냥 사이즈가 있는 박스다 height 또는 width 프로퍼티가 필요하다

* SizedBox( )

  * height :

    높이

  * width:

    너비

## Padding( )

여백을 만든다

* Padding()

  * child: 

    여백을 적용시킬 오브젝트를 안에 작성

  * padding:

    * EdgeInsets.all

      상하좌우에 여백 10을 준다

    * Edgeinsets.only( )
  
      한곳에만 여백을 준다
  
      * top :
      * Bottom:
      * left:
      * right:

    * Edgeinsets.symmetric( )

      수평, 수직여백을 설정할 수 있다.

      * horizontal : 숫자
  
        수평 여백
  
      * vertical : 
      
        수직 여백
      
      * 나머지는 플러터 참고

## Countainer( )

컨테이너는 html의 div와 같다. 단순한 상자이다. sizedBox는 공백 상자라고 생각하면 편하고 컨테이너는 안에 뭔가를 넣을 수 있는 상자다

* Container()

  * decoration: 

    * BoxDecoration( )

      박스를 꾸민다.

      * color:

        박스의 색깔을 꾸민다 

      * borderRadius:

        박스 모서리 옵션

        * BorderRadius.circular(숫자)

          모서리 원형으로 

  * clipBehavior:

    * Clip

      .hardEdge는 나머지 오버플루된(넘친) 오브젝트를 컨테이너 크기에 맞춰 잘라버린다

  * child:

    컨테이너 안에 어떤 기능을 넣을건지 쓴다
    
  * alienment:
  
    정렬한다
  
    * Alignment
  
      .bottomCenter는 아래에서 중앙으로 정렬한다

## Icon( )

아이콘 위젯으로 아이콘을 손쉽게 나타낼 수 있다

* Icon()

  * Icons.

    아이콘 뒤에 원하는 아이콘을 선택하면 된다

  * color: 

    아이콘의 색깔을 꾸민다

  * size:

    아이콘의 크기를 조절한다

## Transform.

오브젝트의 크기나 위치를 변경시킨다

* Transform.scale( )

  * scale: 숫자

    숫자 만큼 배율을 적용한다.

  * child: 

    크기를 아에 변형시킬(다른 영역까지 침범하게끔) 오브젝트를 여기에 넣기

* Transform.translate( )

  * offset:

    * Offset(X,Y)

      X축과 Y축 얼마만큼 이동할건지

  * child:

    다른 영역을 침범하면서 이동시킬 오브젝트를 여기에 넣기

## SingleChildScrollView( )

이 위젯은 화면을 스크롤 할 수 있게 해주는 위젯이다.

* SingleChildScrollView( )
  * child:
    * 스크롤 할 오브젝트를 여기에 놓는다. 

## Stateful Widget

Stateful Widget은 데이터가 변경되면 해당 위젯의 ui가 변경 된다.

setState 메서드는 State클래스에게 데이터가 변경 됐다고 알리는 함수다. 그러면 state는 build메서드를 다시 실행한다.

### setState()

이 메서드를 변화가 있어야 하는 메서드 안에 넣는다

```dart
setState((){
  //데이터 변경 코드
});
```

Stateful과 Stateless 위젯과의 변환은 코드액션에서 Convert to ~를 선택하면 바뀐다

단축키는 st만 입력하면 된다.

## Stateless Widget

Stateless Widget은 데이터가 변경되어도 해당 위젯은 아무 변화가 없다.

Stateful과 Stateless 위젯과의 변환은 코드액션에서 Convert to ~를 선택하면 바뀐다

단축키는 st만 입력하면 된다.

## 변수

text에 변수를 넣을려면 $를 앞에 넣는다

```dart
int num1 = 0;
Text('$num1 는 0이다')
```

## IconButton( )

IconButton은 아이콘 모양의 버튼이다. onPressed:와 icon: 파라미터가 자동으로 생성되는데 onPressed:는 클릭시 적용할 함수를 작성하면 되고 icon:은 아이콘 모양을 지정한다.

* IconButton( )

  * onPressed:

    클릭시 적용할 함수 이름 작성. 괄호( )는 생략

    적용될 클래스 안에 메서드를 만들어준다.

    이 것도 삼항연산자로 조건에 따라 실행할 함수를 다르게 가능

  * Icon:

    아이콘 모양 지정

    ?: 삼항연산자로 조건에 따라 표시 가능
  
  * iconSize: 숫자
  
    아이콘 사이즈 설정

## 테마

Materialapp( )에서 테마를 만들 수 있다

```dart
//원래 메인 함수에서 작성
@override
Widget build(BuildContext context) {
  return MaterialApp(
  	theme: ThemeData(
    	textTheme: const TextTheme(
      	titleLarge: TextStyle(
        	color: Colors.red,
        ),//TextStyle
      ),//TextTheme
    ),//ThemeData
  ),//MaterialApp
}
```

* MaterialApp( )
  * theme:
    * ThemeData( )
      * textTheme:
        * TextTheme( )
          * titleLarge: 
            * TextStyle( ) 위에 참고

이렇게 작성해놓으면 다른 클래스에서 테마를 사용하고 싶을 때

```dart
Text('My Large Title', 
    style: TextStyle(fontSize: 30, color:Theme.of(context).textTheme.titleLarge!.color),
//값이 확실하게 있어서 널을 방지할 수 있다고 !를 뒤에 작성함
```

Theme.of(context)로 작성하고 안에 프로퍼티는 .으로 접근

## Flexible( )

UI에 기반하여 크기를 정하게 해줌

```dart
Flexible(child: )
```

* Flexible()

  * flex: 숫자

    1이 기본값이다. 비율을 정할 수 있다

  * child:

    container나 다른 위젯들을 넣어줄 수 있다

컨테이너나 사이즈박스, col, row등등 flexible로 얘네들을 감싸줄 수 있다.

## Expanded( )

영역을 확장한다? container나 sizebox가 col이나 row에 있으면 끝까지 넓혀서 영역을 확장시킨다

* Expanded()

  * child:

    container나 다른 위젯들을 넣어준다

## Timer( )

타이머 관련 옵션이다

* Timer( )

  * .periodic(duration, (timer){})

    주기마다 이 함수를 실행함. duration에 주기를 작성하기. (timer) {}에다가 주기마다 실행할 함수 이름을 작성하기(괄호 쓰지 않기!)

    * Duration(seconds:1)
    * 함수 이름

* Timer.Cancel();

  타이머 멈추기

```dart
//예시
timer = Timer.periodic(const Duration(seconds: 1), onTick); //Duration은 주기, onTick은 함수 이름
```



## flutter 생명 주기

1.initState( )

build를 하기 전에 항상 먼저 한번만 실행된다. 대표적으로 API를 불러올 때 사용된다

클래스에서 변수를 선언하는데 가끔 initState안에서 변수를 초기화 한다

2.dispose( )

화면에서 사라질 때 실행된다. 무언가를 취소하고 싶을 때 사용

3.build( )

build는 나의 위젯에서 ui를 만든다

## await

함수 앞에다가 또는 변수 앞에다가 await 수식어를 붙히면 데이터가 제대로 들어올 때까지 다음 코드로 넘어가지 않고 기다린다(Future 타입)

```dart
await http.get(url);
```

await은 비동기 함수(async) 내에서만 사용 가능하다

```dart
Future<List<WebtoonModel>> getTodaysToon() async //url 불러오는 메서드
{
  final url = Uri.parse('$baseUrl/$today');
  await http.get(url);
}
```

그리고 반환 형식을 Future로 감싸줘야 한다

## HTTP(URL)

url은 웹사이트의 주소를 다루는 것으로 pub.dev에 가서 url패키지를 설치해야 한다. http검색 해보기

pubspec.yaml 파일에 dependencies: 안에다가 "http: ^0.13.5" 입력 후 저장하고 상단에 다운로드 버튼 클릭

코드액션을 누르면 import 'package:http/http.dart'를 vscode에서 작성해주는데  as http;를 추가로 내가 작성해준다

* http.get(url)

  특정 url에 요청을 보낸다

* Uri.parse('문자열');

  URL을 받아오는 함수

## FutureBuilder

FutureBuilder는 데이터가 기다리는 동안 어떤 기능을 작동하게 하는 함수다

statefulWidget을 쓸 필요가 없다

builder라는 매개변수가 필요함.

await를 쓸 필요가 없게 됨.

* Scaffold( )

  * body:

    *  FutureBuilder( )

      * future: 

        await을 쓸 필요가 없게 됨 future에서 자동으로 기다려줌?

      * builder: (context, snapshot) { }

        builder에 전달하는 매개변수중 context는 앞에 얘기 했던 제일 상위의 클래스나 메서드를 사용할 수 있게 해주고

        snapshot은 Future의 상태를 알 수 있다 {} 안에서 future.hasdata는 데이터를 받았는지 여부고, future.error는 오류가 났는지 여부이다. 이는 더 찾아봐야 한다



6.7부터 시작1

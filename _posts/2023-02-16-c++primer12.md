---
layout: single
title: "C++ primer 12"
categories: C++_primer
tags: [c++]
author_profile: false
#search: false
published: true
---

### begin 과 end라이브러리 함수

끝 지난 포인터를 직접 계산할 수 있지만 이는 오류가 생기기 쉽다 포인터를 더 쉽고 안전하게 쓸 수 있도록 라이브러리에 새로운 두 함수 begin과 end를 추가했다. 이 함수는 명명한 컨테이너 멤버와 비슷하게 행동한다. 하지만 배열은 클래스 타입이 아니므로 이 함수는 멤버 함수가 아니며, 대신 배열을 인자로 취한다.

```c++
int ia[] = {0,1,2,3,4,5,6,7,8,9}; //ia는 int가 10개인 배열이다
int *beg = begin(ia); //ia의 첫 요소에 대한 포인터
int *last = end(ia); //ia의 마지막 요소 다음 위치에 대한 포인터
```

begin에서는 지정한 배열의 첫 요소에 대한 포인터를 반환하고 end에서는 마지막 요소 바로 다음 위치에 대한 포인터를 반환한다. 이 함수는 iterator헤더에서 정의한다.

begin과 end를 사용하면 배열 내 요소를 처리하는 루프를 쉽게 만들 수 있다 예를 들어 arr이 int 값을 담는 배열이라면 배열 내 첫 번째 음수 값을 다음처럼 찾을 수 있다

```c++
int *pbeg = begin(arr), *pend = end(arr);

while(pbeg != pend && *pbeg >= 0)
    ++pbeg;
```

### 포인터 산술 연산

포인터도 반복자처럼 모든 반복자 연산을 사용할 수 있다. 정수 값을 포인터에 더하거나 빼면 새로운 포인터를 결과로 얻는다. 이 새로운 포인터는 지정한 값만큼 원래 포인터 앞 또는 뒤에 있는 요소를 가리킨다.

```c++
constexpr size_t sz = 5;
int arr[sz] = {1,2,3,4,5};
int *ip = arr; //int *ip = &arr[0]와 같다
int *ip2 = ip + 4; //ip2는 arr의 마지막 요소인 arr[4]를 가리킨다
```

ip에 4를 더한 결과는 현재 ip에서 가리키는 요소에서 네 요소 더 뒤에 있는 요소를 가리키는 포인터이다. 포인터에 정수 값을 더한 결과는 같은 배열 내 요소에 대한 포인터이거나 배열의 마지막 요소 바로 다음 위치에 대한 포인터여야 한다.

반복자 처럼 두 포인터를 빼면 포인터 사이의 거리를 반환하는데, 요소 개수이다.

```c++
auto n = end(arr) - begin(arr); //n은 5
```

두 포인터를 뺀 결과는 ptrdiff_t 라이브러리 타입이다. size_t처럼 이 타입 역시 시스템 한정적인 타입이며 cstddef 헤더에서 정의한다 부호 있는 정수 타입이다.

관계 연산자를 사용해 배열 요소를 가리키는 포인터네 마지막 요소 바로 다음 위치를 가리키는 포인터를 비교할 수 있다. 예를 들면 arr의 요소를 다음처럼 훑을 수 있다

```c++
int *b = arr, *e = arr + sz;
while(b < e)
{
    //*b를 사용한다
    ++b;
}
```

관계없는 두 객체에 대한 포인터에 관계 연산자를 사용할 수 없다

```c++
int i = 0, sz = 42;
int *p = &i, *e = &sz;
while(p < e)//오류
```

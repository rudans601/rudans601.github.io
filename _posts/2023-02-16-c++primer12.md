---
layout: single
title: "C++ primer 12"
categories: C++_primer
tags: [c++]
author_profile: false
#search: false
---

# 표현식

표현식은 피연산자 하나 이상으로 구성하며 평가하면 결과를 반환한다

## 기본 개념

연산자에는 단항 연산자와 이항 연산자가 있다. 주소와 역참조등이 단항 연산자에 속하고 피연산자 하나에 대해 작동한다. 상등과 곱셈등이 이항 연산자에 속하며 피연산자 둘에 대해 작동한다.

\*과 같은 일부 기호는 단항(역참조)과 이항(곱셈) 연산자 모두로 사용한다. 맥락에 따라 파악한다.

### 연산자와 피연산자를 하나로 묶기

연산자가 여러개가 된다면 연산자 우선순위와 결합법칙을 이해해야 한다 그리고 피연산자 평가 순서에 따라 표현식에 대한 이해가 달라질 수도 있다

### 피연산자 변환

표현식을 평가하는 과정에서 종종 피연산자를 다른 타입으로 변환한다. 예를 들면 이항 연산자에서는 피연산자가 같은 타입일 것을 예상 하므로 피연산자를 공통 타입으로 변환 할 수 있으면 타입이 서로 달라도 이러한 연산자를 사용할 수 있다.

### 다중 정의한 연산자

언어에서는 연산자의 의미를 정의하지만 클래스 타입에 연산자를 적용할 때 의미를 직접 정의할 수 있다. 이를 다중 정의한 연산자(연산자 오퍼레이터)라고 한다. 연산자 의미를 바꿀 수는 있지만 피연산자 수, 연산자 우선순위와 결합법칙은 바꿀 수 없다

### 좌변값과 우변값

c++에서 모든 표현식은 우변 값과 좌변 값 중 하나이다. 좌변 값에는 대입 왼쪽에 놓을 수 있으나 우변 값은 못한다.

c++에서 좌변 값 표현식은 객체나 함수를 반환하지만 const 객체와 같은 일부 좌변 값은 대입의 왼쪽 피연산자가 될 수 없다. 또한 일부 표현식에서는 좌변 값이 아니라 우변 값인 객체를 반환한다. 객체를 우변 값으로 사용하면 객체의 값(내용)을 사용하는 것이고, 좌변 값으로 사용하면 객체의 정체성(메모리 내 객체 위치)를 사용한다

연산자에서 피연산자로 좌변 값과 우변 값 중 어느 것을 쓰느냐와 좌변 값과 우변 값 중 어느 것으로 반환하느냐는 다르다. 중요한 것은 우변 값이 필요할 때 좌변 값을 대신 쓸 수 있으나 좌변 값(즉 메모리 위치)이 필요할 때 우변 값을 대신 쓸수는 없다는 것이다. 한가지 예는 13.6절에서 다룬다

우변 값을 써야 할때 좌변 값을 쓰면 해당 객체의 내용(객체의 값)을 사용한다

- 대입에서는 왼쪽 피연산자로 (const가 아닌) 좌변 값을 쓰고 왼쪽 피연산자를 좌변 값으로 반환한다.

- 주소 연산자에서는 좌변 값 피연산자를 쓰고 피연산자에 대한 포인터를 우변 값으로 반환한다.

  ```c++
  int ival = 42;
  int *p = &ival;
  ```

- 내장 역참조와 첨자 연산자, 반복자 역참조, string과 vector 첨자 연산자에서는 모두 좌변 값을 반환한다

- 내장/반복자 증가, 감소 연산자에서는 좌변 값 피연산자를 쓰고 이 연산자와(지금까지 사용한 것 중 하나인) 전위 버전 모두 좌변 값을 반환한다.

위의 내용처럼 연산자에 좌변 값을 써야 하는지, 연산자가 좌변 값을 반환하는지 주의한다

또한 좌변 값과 우변 값은 decltype과 함께 쓸 때도 다르다. (변수 이외의) 표현식에 decltype을 적용할 때, 그 표현식에서 좌변 값을 반환하면 결과는 참조자 타입이다.

예를 들어 int \*p 가 있으면 역참조하면 좌변값을 반환 하므로

```c++
decltype(*p)
```

는 int& 이다.

주소연산자에서는 우변 값을 반환하므로

```c++
decltype(&p)
```

는 int\*\*, 포인터의 포인터이다.

## 우선순위와 결합법칙

곱,나눗셈이 덧셈뺄셈보다 우선이다.

### 괄호로 우선순위와 결합법칙 재정의하기

괄호를 사용하면 우선적으로 계산할 수 있게 해준다

### 우선순위와 결합법칙이 중요할 때

우선순위가 프로그램의 결과에도 영향을 준다

```c++
int ia[] = {0,2,4,6,8};
int last = *(ia + 4); //last를 ia[4]값인 8로 초기화
last = *ia + 4; //last = 4이며 ia[0] + 4와 같다
```

괄호가 있거나 없으면 실행에 차이가 생긴다.

io연산자는 왼쪽 결합이다

cin >> v1 >> v2; //읽은 데이터를 v1에 넣고 그 다음은 v2에 넣는다

## 평가 순서

우선순위는 피연산자를 묶는 방법을 지정할 뿐 피연산자를 평가하는 순서는 알려주지 않는다.

평가순서가 보장된 연산자는 and(&&)연산자와 논리or(||),조건 연산자(?:), 쉼표(,)연산자 뿐이다.

And(&&)연산자는 왼쪽 피연산자를 먼저 평가함을 보장한다. 그리고 왼쪽 피연산자가 true일 때에만 오른쪽 피연산자를 평가함도 보장한다.

### 평가순서, 우선순위, 결합법칙

피연산자 평가 순서는 우선순위, 결합법칙과 관계 없다. f() + g() \* h() + j()와 같은 표현식에서

- 우선순위에 따라 g()와 h()의 결과를 곱함을 보장한다
- 결합 법칙에 따라 f()결과를 g() 와 h()의 곱에 더하고, 더한 결과를 j() 값에 더함을 보장한다.
- 함수 호출 순서는 보장하지 않는다

f,g,h,j가 같은 객체의 상태에 영향을 주지 않거나 IO를 처리하지 않는 독립적인 함수라면 이 함수 호출 순서는 상관 없다

중요! 피연산자 값을 변경하면 그 피연산자를 같은 표현식 내 다른 곳에서 사용하지 않는다

예외는 피연산자를 변경하는 하위 표현식 그 자체가 다른 하위 표현식의 피연산자일때이다. 예를 들면 \*++iter에서 증가 연산자는 iter 값을 변경한다

# 산술 연산자

이 연산자들은 모두 왼쪽 결합, 우선순위가 같을 때 왼쪽에서 오른쪽으로 묶는다는 뜻이다. 피연산자와 이 연산자의 결과는 우변 값이다.

| 연산자 |    기능     |        사용        |
| :----: | :---------: | :----------------: |
|   +    | 단항 양수화 |      + 표현식      |
|   -    | 단항 음수화 |      -표현식       |
|  ---   |     ---     |        ---         |
|   \*   |    곱셈     | 표현식1 \* 표현식2 |
|   /    |   나눗셈    | 표현식1 / 표현식2  |
|   %    |   나머지    | 표현식1 % 표현식2  |
|  ---   |     ---     |        ---         |
|   +    |    덧셈     | 표현식1 + 표현식2  |
|   -    |    뺄셈     | 표현식1 - 표현식2  |

주의사항 : bool타입은 산술 연산 하지 말자, 0으로 나누지 말자, 나머지 연산자의 피연산자들은 전부 정수 타입이어야 한다

나눗셈에서 피연산자 부호가 같으면 0이 아닌 몫은 부호가 양이고 그렇지 않으면 음이다. (이게 뭔 문장이야??)

# 논리와 관계 연산자

### 논리 AND와 OR연산자

|  결합  | 연산자 |       기능       |         사용         |
| :----: | :----: | :--------------: | :------------------: |
| 오른쪽 |   !    |     논리 NOT     |       !표현식        |
|  ---   |  ---   |       ---        |         ---          |
|  왼쪽  |   <    |    보다 작다     |  표현식1 < 표현식2   |
|  왼쪽  |   <=   | 보다 작거나 같다 |  표현식1 <= 표현식2  |
|  왼쪽  |   >    |    보다 크다     |  표현식1 > 표현식2   |
|  왼쪽  |   >=   | 보다 크거나 같다 |  표현식 >= 표현식2   |
|  ---   |  ---   |       ---        |         ---          |
|  왼쪽  |   ==   |       같다       |  표현식1 == 표현식2  |
|  왼쪽  |   !=   |    같지 않다     |  표현식1 != 표현식2  |
|  ---   |  ---   |       ---        |         ---          |
|  왼쪽  |   &&   |     논리AND      |  표현식1 && 표현식2  |
|  ---   |  ---   |       ---        |         ---          |
|  왼쪽  |  \|\|  |      논리OR      | 표현식1 \|\| 표현식2 |

- &&는 왼편이 true일 때에만 오른편을 평가한다
- ||는 왼편이 false일 때에만 오른편을 평가한다

### 논리 NOT연산자

논리 NOT연산자(!)에서는 해당 피연산자에 대한 진리 값의 역을 반환한다.

### 관계 연산자

관계 연산자는 일반적으로 사용하는 의미 그대로이며 bool값을 반환한다.

### 상등 비교와 bool상수

상등 비교는 값을 피연산자의 값이 같은지 확인할 때 쓰인다. bool 상수는 bool 변수에만 사용하는 것을 추천한다

# 대입 연산자

보통 변수에 대입할 때 사용한다

새로운 표준에서는 중괄호 초기 값 목록을 오른 편에 사용할 수 있다

```c++
int k = 0;
k = {3.14}; //오류: 축소 변환시에는 중괄호 초기값 사용 불가

vector<int> vi;
vi = {0,1,2,3,4,5,6,7,8,9};
```

## 대입은 오른쪽 결합이다

다른 이항 연산자와 달리 대입은 오른쪽 결합이다

```c++
ival = jval = 0; //각각에 0을 대입한다
```

다중 대입 시에 각 객체는 각각의 오른쪽 이웃 객체와 타입이 같거나 그 이웃 객체 타입으로 변환할 수 있어야 한다

## 대입은 우선순위가 낮다

```c++
while((i = get_value()) != 42)
{
  //뭔가를 보여드리겠습니다
}
```

이 식은 get_value에서 얻은 값을 i에 대입 하고 이 값을 42와 비교해서 아니면 반복문을 실행한다. 보통 이런식으로 조건식에 대입을 넣어서 더 명확하게 식을 줄일 수 있다.

## 상등과 대입 연산자를 헷갈리지 말자

```c++
if(i = j)
```

이 식은 j를 i에 대입하고 이 대입 결과가 0이 아니면 조건은 전부 참이다

## 복합 대입 연산자

객체에 연산자를 적용 후 그 결과를 같은 객체에 대입할 때 사용한다.

- +=, \*=, /=, %= 는 산술 연산자
- <<=, >>=, &=, ^=, |= 는 비트 연산자

```c++
a += 1; //a에 1을 더한후 a에 다시 저장
```

복합 대입을 사용할 때 왼쪽 피연산자는 단 한번만 평가한다.

일반 대입은 오른쪽 피연산자를 평가할 때 한번, 왼쪽 피연산자로 또 한번, 피연산자를 모두 두 번 평가한다.

## 증가와 감소 연산자

증가와 감소 연산자를 사용하면 객체에 1을 더하거나 뺄때 간편하게 표기할 수 있다. 그리고 이 연산자는 많은 반복자에서 사용한다. 전위 연산자와 후위 연산자로 나뉜다.

전위 연산자는 피연산자를 증가/감소 시키고 변경한 객체를 결과로 반환한다.

후위 연산자는 변경하지 않은 피연산자를 결과로 반환하고 증가/감소 시킨다. 후위연산자는 필요할 때만 사용한다.

### 표현식 하나에서 역참조와 증가 결합하기

후위증가를 사용해 첫 번째 음수 값을 만날때 까지 반복하며, 이 음수 값을 제외하고 vector내 값을 출력하는 루프를 만들 수 있다

```c++
auto pbeg = v.begin();

while (pbeg != v.end() && *beg >= 0)
  cout << *pbeg++ << endl; //현재 값을 출력하고 pbeg를 앞으로 이동한다
```

후위 증가의 우선순위는 역참조 연산자보다 높으므로 _pbeg++는 _(pbeg++)와 같다

### 피연산자 평가 순서는 정해져 있지 않음을 기억한다

연산자 대부분에서 피연산자 평가 순서를 보장하지 않는데 이는 중요하지 않다. 평가 순서가 중요한 경우는 다른 하위 표현식에서 사용하는 피연산자의 값을 한 하위 표현식에서 변경할 때이다. 증가와 감소 연산자에서는 피연산자를 변경하므로 복합 표현식에서 이 연산자를 잘못쓰기 쉽다. 주의해야 한다

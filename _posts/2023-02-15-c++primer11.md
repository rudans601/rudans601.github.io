---
layout: single
title: "C++ primer 11"
categories: C++_primer
tags: [c++]
author_profile: false
#search: false
---

### begin 과 end라이브러리 함수

끝 지난 포인터를 직접 계산할 수 있지만 이는 오류가 생기기 쉽다 포인터를 더 쉽고 안전하게 쓸 수 있도록 라이브러리에 새로운 두 함수 begin과 end를 추가했다. 이 함수는 명명한 컨테이너 멤버와 비슷하게 행동한다. 하지만 배열은 클래스 타입이 아니므로 이 함수는 멤버 함수가 아니며, 대신 배열을 인자로 취한다.

```c++
int ia[] = {0,1,2,3,4,5,6,7,8,9}; //ia는 int가 10개인 배열이다
int *beg = begin(ia); //ia의 첫 요소에 대한 포인터
int *last = end(ia); //ia의 마지막 요소 다음 위치에 대한 포인터
```

begin에서는 지정한 배열의 첫 요소에 대한 포인터를 반환하고 end에서는 마지막 요소 바로 다음 위치에 대한 포인터를 반환한다. 이 함수는 iterator헤더에서 정의한다.

begin과 end를 사용하면 배열 내 요소를 처리하는 루프를 쉽게 만들 수 있다 예를 들어 arr이 int 값을 담는 배열이라면 배열 내 첫 번째 음수 값을 다음처럼 찾을 수 있다

```c++
int *pbeg = begin(arr), *pend = end(arr);

while(pbeg != pend && *pbeg >= 0)
    ++pbeg;
```

### 포인터 산술 연산

포인터도 반복자처럼 모든 반복자 연산을 사용할 수 있다. 정수 값을 포인터에 더하거나 빼면 새로운 포인터를 결과로 얻는다. 이 새로운 포인터는 지정한 값만큼 원래 포인터 앞 또는 뒤에 있는 요소를 가리킨다.

```c++
constexpr size_t sz = 5;
int arr[sz] = {1,2,3,4,5};
int *ip = arr; //int *ip = &arr[0]와 같다
int *ip2 = ip + 4; //ip2는 arr의 마지막 요소인 arr[4]를 가리킨다
```

ip에 4를 더한 결과는 현재 ip에서 가리키는 요소에서 네 요소 더 뒤에 있는 요소를 가리키는 포인터이다. 포인터에 정수 값을 더한 결과는 같은 배열 내 요소에 대한 포인터이거나 배열의 마지막 요소 바로 다음 위치에 대한 포인터여야 한다.

반복자 처럼 두 포인터를 빼면 포인터 사이의 거리를 반환하는데, 요소 개수이다.

```c++
auto n = end(arr) - begin(arr); //n은 5
```

두 포인터를 뺀 결과는 ptrdiff_t 라이브러리 타입이다. size_t처럼 이 타입 역시 시스템 한정적인 타입이며 cstddef 헤더에서 정의한다 부호 있는 정수 타입이다.

관계 연산자를 사용해 배열 요소를 가리키는 포인터네 마지막 요소 바로 다음 위치를 가리키는 포인터를 비교할 수 있다. 예를 들면 arr의 요소를 다음처럼 훑을 수 있다

```c++
int *b = arr, *e = arr + sz;
while(b < e)
{
    //*b를 사용한다
    ++b;
}
```

관계없는 두 객체에 대한 포인터에 관계 연산자를 사용할 수 없다

```c++
int i = 0, sz = 42;
int *p = &i, *e = &sz;
while(p < e)//오류
```

참고사항: 널포인터에 값이 0인 정수 상수 표현식을 더하거나 뺄 수 있다. 또한 두 널포인터를 뺄 수 있으며 결과는 0이다. 배열이 아닌 객체에 대한 포인터의 산술 연산 역시 유효하며 그 포인터는 같은 객체나 그 객체 바로 다음 위치를 가리켜야 한다.

### 역참조와 포인터 산술 연산 사이의 상호작용

결과로 얻는 포인터에서 요소를 가리킨다면 이 포인터를 역참조할 수 있다.

```c++
int ia[] = {0,2,4,6,8}; //int 타입 요소가 5개인 배열
int last = *(ia + 4) //좋음 : last를 ia[4] 값인 8로 초기화 한다
```

### 첨자와 포인터

배열 내 요소나 배열의 마지막 요소 바로 다음 위치를 가리키는 모든 포인터에 첨자 연산자를 사용할 수 있다. 포인터에 배열의 특정 첨자를 주소로 넣고 그 포인터를 연산해도 된다는 의미이다.

```c++
int ia[] = {0,2,4,6,8};

int *p = &ia[2]; //p는 ia[2]의 주소를 저장
int j = p[1]; //p[1]은 *(p + 1)과 같으며 p[1]은 ia[3]과 같은 요소이다
int k = p[-2]; //p[-2]은 ia[0]과 같은 요소이다
```

내장 첨자 연산자는 unsigned 타입이 아니다. 부호 없는 타입이 아니다.

## C형식 문자열

C++에서 C형식 문자열을 지원하지만 이 문자열을 C++ 프로그램에서 쓰지 않는 것이 좋다.

### C라이브러리 문자열 함수

c형식 문자열 함수는 cstring 헤더에서 정의하는데 이는 c언어 헤더 string.h의 c++ 버전이다

- strlen(p) : 널 문자를 제외한 p 길이 반환
- strcmp(p1,p2) : p1과 p2가 같은지 비교해서 같으면 0, p1> p2는 양수, p1< p2는 음수이다.
- strcat(p1,p2) : p2를 p1에 추가하고 p1을 반환한다
- strcpy(p1,p2): p2를 p1에 복사하고 p1을 반환한다

이 함수에 전달하는 포인터는 반드시 널 문자로 마친 배열에 대한 포인터여야 한다

### 문자열 비교하기

c++의 string 라이브러리는 그냥 상등 연산자를 사용하면 됐지만 c형식 문자열은 strcmp를 사용해야 한다.

### 목적지 문자열의 크기는 호출하는 쪽에서 책임진다

c형식 문자열을 연결하거나 복사하는 것 역시 같은 연산을 string 라이브러리에 하는 것과는 매우 다르다.

```c++
string largeStr = s1 + " " + s2;
```

string은 이렇게 해도 되지만 c형식 문자열 두개를 위와 같이 연산할려면 오류가 발생한다. strcat과 strcpy를 사용하는데

```c++
strcpy(ca1, ca2);
strcat(ca1, " ");
strcat(ca1, ca2);
```

문자열 ca1은 합치던지 붙히던지 해서 널 문자를 포함할 정도까지 크기가 커야한다.

## 오래된 코드와 함께 쓰기

c++ 라이브러리에는 vector와 string을 쓰지 않는 오래된 코드와 함께 쓸수 있도록 여러 기능을 제공한다

```c++
string s("Hello World");
```

- 널 종료 문자 배열을 사용해 string을 초기화 하거나 string에 대입 가능하다
- 널 종료 문자 배열을 string 덧셈 연산자의(양쪽 피연산자가 아니라) 한쪽 피연산자나 string 복합 대입(+=) 연산자의 오른쪽 피연산자로 쓸 수 있다.

이 역에 해당하는 기능은 제공하지 않는다.

문자 포인터를 string으로 초기화 할 방법은 string 멤버 함수 c_str이 있다.

```c++
char *str = s; //오류: char*를 string으로 초기화 할 수 없다
const char *str = s.c_str(); //좋음
```

프로그램이 c_str로 반환한 배열 내용에 계속 접근해야 한다면 반환한 배열을 반드시 복사해야 한다.

### 배열을 사용해 vector 초기화하기

내장 배열을 다른 배열로 초기화 할수 없고 vector로 배열을 초기화 할 수 없지만 배열을 사용해 vector는 초기화 할 수 있다 그렇게 할려면 복사하려는 첫 요소와 마지막 요소 바로 다음 위치에 대한 포인터를 지정한다

```c++
int int_arr[] = {0,1,2,3,4,5}; //ivec는 요소가 6개이며 각각은 int_arr의 해당 요소 복사본이다
vector<int> ivec(begin(int_arr) , end(int_arr));
```

ivec를 생성하는 데 사용한 두 포인터는 ivec의 요소를 초기화 하는데 사용할 값 범위를 표시한다. 이렇게 하면 복사된다.

배열의 하위 집합을 범위로 지정할 수 있다.

```c++
vector<int> subVec(int_arr + 1, int_arr + 4); //int_arr 1~3까지 복사한다
```

# 다차원 배열

c++에는 다차원 배열이 없고 엄격히 말하면 배열의 배열이다.

### 다차원 배열 요소 초기화 하기

```c++
int ia[3][4] = { //3행 4열
    {0,1,2,3},
    {4,5,6,7},
    {8,9,10,11}
};
```

중첩된 중괄호는 선택사항이다.

1차원 배열처럼 요소를 초기값 목록에서 제외할 수 있다. 각 행별 첫 요소만 초기화 할수 있다.

```c++
int ia[3][4] = {{0},{4},{8}};
```

남은 요소는 1차원 배열과 같은 방법으로 값 초기화 한다.

중괄호를 생략하면 앞에서부터 차례대로 요소를 초기하고 남은 요소는 0으로 초기화 된다.

### 다차원 배열 첨자 연산하기

다른 배열처럼 첨자 연산을 사용해 다차원 배열에 접근할 수 있다. 그러면 각 차원별로 첨자를 써야 한다. 표현식에서 첨자 수를 차원만큼 사용하면 지정한 타입인 요소를 얻지만 첨자수가 차원보다 적으면 지정한 색인에 위치한 내부 배열 요소를 얻는다

```c++
ia[2][3] = arr[0][0][0];
int (&row) [4] = ia[1]; //row를 ia의 두번째 배열(요소는 4개)에 결합한다
```

row를 int가 4개인 배열에 대한 참조자로 정의하고 이 참조자를 ia의 두번째 행과 결합한다

### 다차원 배열에 범위 for 사용하기

새로운 표준에서는 범위 for를 사용해 앞에서 본 루프를 간단히 할 수 있다

```c++
size_t cnt = 0;
for (auto &row : ia) //바깥 배열의 모든 요소에 대해
    for (auto &col : row) { //안쪽 배열의 모든 요소에 대해
        col = cnt; //이 요소에 현재 값을 대입
        ++cnt; //cnt 증가
    }
```

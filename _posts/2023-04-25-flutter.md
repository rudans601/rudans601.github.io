---
layout: single
title: "플러터 노트01"
categories: flutter
tags: [flutter]
author_profile: false
#search: false

---

# flutter 정리

## flutter VSC code action

vscode의 코드 액션을 간단하게 설명

* Wrap with ~

  ~로 감싸준다

* Wrap with widget

  커스텀 위젯으로 감싸준다 이름은 내가 지정하기

* Remove this ~

  ~를 제거해줌

* Extract Widget

  드래그 한 부분을 위젯으로 내보낸다. 위젯 이름 지정

  위젯을 만들면 밑에 위젯이 만들어지는데 이 위젯을 기능별로 폴더와 파일을 만들어서 붙혀넣기 하고 임포트 하는게 나중에 유지보수 하기에 더 좋다.

  ```dart
  import 'package:flutter/material.dart'; //import를 컴파일러가 추천해서 자동 작성하거나 아니면 내가 작성
  
  class MyWidget extends StatelessWidget { //st를 입력하면 손쉽게 작성 가능, 보통은 stateless로 작성
    final String text; //전달 받고 싶은 인자를 만들어줌 1
    final Color bgColor; //전달 받고 싶은 인자를 만들어줌 2
    final int num1; //전달 받고 싶은 인자를 만들어줌 3
    final _blackColor = const Color(0xFF1F2123); //변수 앞에 _언더바는 private 접근지정자이다.
    
    const MyWidget({ //코드액션으로 final 필드(아래의 생성자 형식)를 만들수 있음
      super.key,
      required this.text, //생성자 안에 required를 써서 인스턴스 작성
      required this.bgColor,
      required this.textColor,
    }); 
  
    @override
    Widget build(BuildContext context) {
      return //내가 만들려는 위젯 붙여넣고 위의 클래스 인자(변수)를 넣어주기;
    }
  }
  ```

  Button 위젯을 만들고 다른 클래스에서 사용할려면

  ```dart
  Button(
    text: 'transfer',
    bgColor: color,
    textColor: Colors.black,
  ),//안에 클래스 인자들을 작성해주면 된다.
  ```

  

* Move widget ~

  위젯을 위나 아래로 움직인다

## 기본구조

```dart
void main()
{
  //App의 ui를 실행하기 전에 백엔드 함수 등등을 만들어서 먼저 실행시킬 수 있다
  runApp(App());
}

class App extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(); //CupertinoApp : ios스타일, MaterialApp() : Android 스타일
  }
}
```

## 참고

위젯이나 메서드에 커서를 두고 나오는 프로퍼티 중에 required는 필수로 작성해줘야 한다

## MaterialApp( ), Scaffold( )

MaterialApp()은 Android 스타일 앱을 만들게 해줌. 테마를 적용할 수 있음

Scaffold()는 모바일 앱의 모든화면에 필요하다. 네비게이션바, 텍스트, 위젯, 박스등등..

* MeterialApp()

  * theme:

    테마 지정

    * TextTheme()

      텍스트의 테마 지정

      * titleLarge: 

        타이틀 크기?

        * TextStyle()

          아래 Text() 참고

  * Scaffold()
  
    * body

      메인이 되는 프로퍼티이다.

      * Center( ) 

        괄호안에 있는 걸 중앙정렬 해줌

      * Column( )
  
        * children[ ]
  
      * Row( )
  
        * children[ ]
        
      * Padding( )
  
    * appBar :
  
      appBar 프로퍼티는 위젯의 일종으로 앱의 상단바를 만들어준다.
  
      * AppBar( )
  
        * title:
    
          title은 제목
    
          * Text( )
    
        * backgroundColor: 
    
          앱바의 색상을 지정
    
        * foregroundColor:
    
          앱바의 텍스트 색상 지정
    
        * elevation:
    
          앱바의 그림자 조정(0부터 ~까지)
    
    * backgroundColor 
    
      배경 색상을 지정한다. 
    
    * BottomnavigationBar :
    
      * BottomAppBar()
    
      * Child : 
    
        자식 넣기
    
        * elevation : 숫자 
    
          그림자 역할을 한다



```dart
void main()
{
  runApp(App());
}

class App extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp( //home 프로퍼티는 가장 메인이 되는 프로퍼티
      appBar: AppBar(
      	title: Text('hello flutter!'),),
      home: Scaffold( //Scaffold의 body는 가장 기본이 되는 프로퍼티
      body: Center(Text('Hello world'),),), 
    ); 
  }
}
```

## Text( )

* Text()

  * style :

    스타일 프로퍼티

    * TextStyle()

      텍스트 스타일 설정 프로퍼티

      * color:

        색상 설정 프로퍼티
        
        * colors.white
        
          색상
        
          * .withOpacity(1)
        
            투명도 0~1
      
      * fontSize: 숫자
      
        폰트 크기
      
      * fontWeight:
      
        폰트 굵기
      
        * FontWeight.w600
      
          숫자가 클수록 굵음
      
        
      
        

```dart
Text('Hello world') //추가 프로퍼티는 쉼표(,)추가하고 플러터 참고
```

## Center( )

```dart
Center(
  child: Text('Hello world'),) //괄호 안에 있는 걸 중앙정렬 해줌, 여러개 넣을려면 쉼표 추가 후 넣기
```

* Center( )
  * child:

## Colors

색상 프로퍼티다. 색상을 표현하는 방법은 여러가지가 있는데

```dart
backgroundColor: Colors.blue; //.shade는 색조다. 숫자로 조정0~900
backgroundColor: Color(0xFF181818), 
backgroundColor: Color.fromARGB(255,145,36,36); //R G B opacity
```

## Column()

수직배열을 만들어낸다. 상자가 아래로 쌓여있는 형태

| 1    |
| ---- |
| 2    |
| 3    |
| 4    |

* Column()

  * mainAxisAlignment : 

    정렬이다. column은 수직방향이므로 수직이 main이다

    * MainAxisAlignment.end

      .center는 가운데 정렬, .end는 오른쪽 정렬, 나머지는 플러터 참고

  * crossAxisAlignment :

    수직의 수직방향으로 정렬이다. 즉, 수평방향으로 정렬한다

    * crossAxisAlignment.end

      .center는 가운데 정렬, .end는 아래로 정렬, 나머지는 플러터 참고

  * children[ ]
  
    자식들을 [ ]대괄호 안에 넣어서 정렬할 수 있다.
    
  * mainAxisSize: 
  
    사이즈 설정
    
    * MainAxisSize.min
    
      사이즈 최소한으로만 

## Row()

수평배열을 만들어낸다. 상자가 오른쪽으로 쌓여있는 형태

|  1   |  2   |  3   |  4   |
| :--: | :--: | :--: | :--: |

* Row( )
  
  * mainAxisAlignment :
  
    정렬이다. Row는 수평방향이므로 수평이 main이다
  
    * MainAxisAlignment.end
  
      .center는 가운데 정렬, .end는 아래로 정렬, 나머지는 플러터 참고
      
      .spaceBetween는 서로 간격을 주는 기능이다.
  
  * crossAxisAlignment :
  
    수평의 수직방향으로 정렬이다. 즉 수직 방향으로 정렬한다.
  
    * crossAxisAlignment.end
  
      .center는 가운데 정렬, .end는 오른쪽 정렬, 나머지는 플러터 참고
  
  * children[ ]
  
    자식들을 [ ]대괄호 안에 넣어서 정렬할 수 있다.
  
  * mainAxisSize:
  
    사이즈 설정
  
    * MainAxisSize.min
    
      사이즈 최소

## SizedBox( )

그냥 사이즈가 있는 박스다 height 또는 width 프로퍼티가 필요하다

* SizedBox( )

  * height :

    높이

  * width:

    너비

## Padding( )

여백을 만든다

* Padding()

  * child: 

    여백을 적용시킬 오브젝트를 안에 작성

  * padding:

    * EdgeInsets.all

      상하좌우에 여백 10을 준다

    * Edgeinsets.only( )
  
      한곳에만 여백을 준다
  
      * top :
      * Bottom:
      * left:
      * right:

    * Edgeinsets.symmetric( )

      수평, 수직여백을 설정할 수 있다.

      * horizontal : 숫자
  
        수평 여백
  
      * vertical : 
      
        수직 여백
      
      * 나머지는 플러터 참고

## Countainer( )

컨테이너는 html의 div와 같다. 단순한 상자이다. sizedBox는 공백 상자라고 생각하면 편하고 컨테이너는 안에 뭔가를 넣을 수 있는 상자다

* Container()

  * decoration: 

    * BoxDecoration( )

      박스를 꾸민다.

      * color:

        박스의 색깔을 꾸민다 

      * borderRadius:

        박스 모서리 옵션

        * BorderRadius.circular(숫자)

          모서리 원형으로 
        
      * boxShadows: 
      
        박스에 그림자를 넣어주기
      
        * blurRadius: 5
      
          그림자 지름
      
        * offset: Offset(0,0)
      
          그림자 위치
      
        * Color: 
      
          그림자 색상
  
  * clipBehavior:
  
    * Clip
  
      .hardEdge는 나머지 오버플루된(넘친) 오브젝트를 컨테이너 크기에 맞춰 잘라버린다
  
  * child:
  
    컨테이너 안에 어떤 기능을 넣을건지 쓴다
    
  * alienment:
  
    정렬한다
  
    * Alignment
  
      .bottomCenter는 아래에서 중앙으로 정렬한다

## Icon( )

아이콘 위젯으로 아이콘을 손쉽게 나타낼 수 있다

* Icon()

  * Icons.

    아이콘 뒤에 원하는 아이콘을 선택하면 된다

  * color: 

    아이콘의 색깔을 꾸민다

  * size:

    아이콘의 크기를 조절한다
  
* Icon:

  * Falcon(FontawesomeIcons.~)

    ~는 검색해서 찾기

## Transform.

오브젝트의 크기나 위치를 변경시킨다

* Transform.scale( )

  * scale: 숫자

    숫자 만큼 배율을 적용한다.

  * child: 

    크기를 아에 변형시킬(다른 영역까지 침범하게끔) 오브젝트를 여기에 넣기

* Transform.translate( )

  * offset:

    * Offset(X,Y)

      X축과 Y축 얼마만큼 이동할건지

  * child:

    다른 영역을 침범하면서 이동시킬 오브젝트를 여기에 넣기

## SingleChildScrollView( )

이 위젯은 화면을 스크롤 할 수 있게 해주는 위젯이다.

* SingleChildScrollView( )
  * child:
    * 스크롤 할 오브젝트를 여기에 놓는다. 

## Stateful Widget

Stateful Widget은 데이터가 변경되면 해당 위젯의 ui가 변경 된다.

setState 메서드는 State클래스에게 데이터가 변경 됐다고 알리는 함수다. 그러면 state는 build메서드를 다시 실행한다.

### setState()

이 메서드를 변화가 있어야 하는 메서드 안에 넣는다 또는 initState에 넣어준다

```dart
@override
void initState(){
  setState((){
  //데이터 변경 코드
	});
}
```

Stateful과 Stateless 위젯과의 변환은 코드액션에서 Convert to ~를 선택하면 바뀐다

단축키는 st만 입력하면 된다.

## Stateless Widget

Stateless Widget은 데이터가 변경되어도 해당 위젯은 아무 변화가 없다.

Stateful과 Stateless 위젯과의 변환은 코드액션에서 Convert to ~를 선택하면 바뀐다

단축키는 st만 입력하면 된다.

## 변수

text에 변수를 넣을려면 $를 앞에 넣는다

```dart
int num1 = 0;
Text('$num1 는 0이다')
```

## IconButton( )

IconButton은 아이콘 모양의 버튼이다. onPressed:와 icon: 파라미터가 자동으로 생성되는데 onPressed:는 클릭시 적용할 함수를 작성하면 되고 icon:은 아이콘 모양을 지정한다.

* IconButton( )

  * onPressed:

    클릭시 적용할 함수 이름 작성. 괄호( )는 생략

    적용될 클래스 안에 메서드를 만들어준다.

    이 것도 삼항연산자로 조건에 따라 실행할 함수를 다르게 가능

  * Icon:

    아이콘 모양 지정

    ?: 삼항연산자로 조건에 따라 표시 가능
  
  * iconSize: 숫자
  
    아이콘 사이즈 설정

## 테마

Materialapp( )에서 테마를 만들 수 있다

```dart
//원래 메인 함수에서 작성
@override
Widget build(BuildContext context) {
  return MaterialApp(
  	theme: ThemeData(
    	textTheme: const TextTheme(
      	titleLarge: TextStyle(
        	color: Colors.red,
        ),//TextStyle
      ),//TextTheme
    ),//ThemeData
  ),//MaterialApp
}
```

* MaterialApp( )
  * theme:
    * ThemeData( )
      * textTheme:
        * TextTheme( )
          * titleLarge: 
            * TextStyle( ) 위에 참고

이렇게 작성해놓으면 다른 클래스에서 테마를 사용하고 싶을 때

```dart
Text('My Large Title', 
    style: TextStyle(fontSize: 30, color:Theme.of(context).textTheme.titleLarge!.color),
//값이 확실하게 있어서 널을 방지할 수 있다고 !를 뒤에 작성함
```

Theme.of(context)로 작성하고 안에 프로퍼티는 .으로 접근

## Flexible( )

UI에 기반하여 크기를 정하게 해줌

```dart
Flexible(child: )
```

* Flexible()

  * flex: 숫자

    1이 기본값이다. 비율을 정할 수 있다

  * child:

    container나 다른 위젯들을 넣어줄 수 있다

컨테이너나 사이즈박스, col, row등등 flexible로 얘네들을 감싸줄 수 있다.

## Expanded( )

영역을 확장한다? container나 sizebox가 col이나 row에 있으면 끝까지 넓혀서 영역을 확장시킨다

* Expanded()

  * child:

    container나 다른 위젯들을 넣어준다

## Timer( )

타이머 관련 옵션이다

* Timer( )

  * .periodic(duration, (timer){})

    주기마다 이 함수를 실행함. duration에 주기를 작성하기. (timer) {}에다가 주기마다 실행할 함수 이름을 작성하기(괄호 쓰지 않기!)

    * Duration(seconds:1)
    * 함수 이름

* Timer.Cancel();

  타이머 멈추기

```dart
//예시
timer = Timer.periodic(const Duration(seconds: 1), onTick); //Duration은 주기, onTick은 함수 이름
```



## flutter 생명 주기

1.initState( )

build를 하기 전에 항상 먼저 한번만 실행된다. 대표적으로 API를 불러올 때 사용된다

클래스에서 변수를 선언하는데 가끔 initState안에서 변수를 초기화 한다

2.dispose( )

화면에서 사라질 때 실행된다. 무언가를 취소하고 싶을 때 사용

3.build( )

build는 나의 위젯에서 ui를 만든다

## await

함수 앞에다가 또는 변수 앞에다가 await 수식어를 붙히면 데이터가 제대로 들어올 때까지 다음 코드로 넘어가지 않고 기다린다(Future 타입)

```dart
await http.get(url);
```

await은 비동기 함수(async) 내에서만 사용 가능하다

```dart
Future<List<WebtoonModel>> getTodaysToon() async //url 불러오는 메서드
{
  final url = Uri.parse('$baseUrl/$today');
  await http.get(url);
}
```

그리고 반환 형식을 Future로 감싸줘야 한다

## HTTP(URL)

url은 웹사이트의 주소를 다루는 것으로 pub.dev에 가서 url패키지를 설치해야 한다. http검색 해보기

pubspec.yaml 파일에 dependencies: 안에다가 "http: ^0.13.5" 입력 후 저장하고 상단에 다운로드 버튼 클릭

코드액션을 누르면 import 'package:http/http.dart'를 vscode에서 작성해주는데  as http;를 추가로 내가 작성해준다

* http.get(url)

  특정 url에 요청을 보낸다

* Uri.parse('문자열');

  URL을 받아오는 함수

## FutureBuilder

FutureBuilder는 데이터가 기다리는 동안 어떤 기능을 작동하게 하는 함수다

statefulWidget을 쓸 필요가 없다

builder라는 매개변수가 필요함.

await를 쓸 필요가 없게 됨.

* Scaffold( )

  * body:

    *  FutureBuilder( )

      * future: 

        await을 쓸 필요가 없게 됨 future에서 자동으로 기다려줌?

      * builder: (context, snapshot) { }

        builder에 전달하는 매개변수중 context는 앞에 얘기 했던 제일 상위의 클래스나 메서드를 사용할 수 있게 해주고

        snapshot은 Future의 상태를 알 수 있다 {} 안에서 future.hasdata는 데이터를 받았는지 여부고, future.error는 오류가 났는지 여부이다. 이는 더 찾아봐야 한다

## ListView( )

리스트뷰는 리스트를 쉽게 사용하기 위해 쓰는 함수다

* ListView( )

  * children[ ]

    요소들을 넣어줄 수 있다

    * for(var 변수 in snapshot.data!)

      ​	Text(webtoon.title)

      이런 식으로 collection for를 안에 넣어줄 수 있다

* ListView.builder( )

  모든 리스트를 다 불러오는 게 아니고 사용자가 보고 있는 아이템만 먼저 불러온다

  * scrollDirection: 

    스크롤 방향 설정

    * Axis.horizental

      수평방향으로 스크롤

    * Axis.vertical

      수직방향으로 스크롤

  * ItemCount:

    리스트 안의 아이템 개수 설정

  * itemBuilder: (context, index) { }

    listview가 아이템을 build할 때 호출하는 함수이다

    return 값으로 아이템을 리턴 해야 한다

    index는 0부터 1씩 늘어나면서 자동으로 부여된다

    ```dart
    itemBuilder: (context, index) {
      var webtoon = snapshot.data![index];
      return Text(webtoon.title);
    }
    ```

  * padding

* ListView.separated( )

  리스트의 아이템들 사이에 구분자를 위젯으로 넣어서 사용할 수 있다

  * 위의 프로퍼티들도 사용 가능

  * separatorBuilder: (context, index) => 

    * SizedBox( )

      리스트에 size박스를 넣어서 요소 사이를 구분해주고 있다

## Image

이미지를 넣을 수 있다

* Image.network(src)

  src에 URL을 넣어주면 된다

## NetworkImage

웹 이미지를 넣을 수 있다

* NetworkImage(url)

## BottomnavigationBar

화면 아래에 네비게이션 바를 만든다

scaffold안에 만든다

* BottomnavigationBar :

  * BottomAppBar()

    * elevation : 숫자 

      그림자 역할을 한다

## SafeArea

자식 위젯에 패딩을 넣어서 디바이스 영역을 앱의 위젯이 침범하는 것을 막아준다. 이걸로 toppadding을 억지로 사용하지 않아도 된다

* SafeArea()
  * child:



## FractionallySizedBox

부모의 크기에 비례해서 크기를 정해주는 위젯

* FractionallySizedBox()

  * child :

  * widthFactor : 숫자

    숫자는 0~1까지. 0.5는 부모 크기의 0.5배이다

## stack

row와 column과 비슷하게 스택은 위젯을 위로 쌓을 수 있게 해줌

* Stack

  * clipBehavior: Clip.none

    자식이 범위 밖을 지나면 자동으로 잘라준다.

## Navigator Push 

화면 전환하는 메서드이다. push는 화면을 새로 이동한다고 생각하면 된다. pop은 가장 상단의 화면을 하나씩 제거한다고 생각하면 된다

클래스 안에 메서드를 만들고,

```c++
void onLoginTap(BuildContext context) { //메서드를 만들고
    Navigator.of(context).push( //Navigator.push()에 전환할 페이지를
      MaterialPageRoute( //MaterialPageRoute()에 넣어주기
        builder: (context) => const LoginScreen(), //이동할 화면의 클래스 넣어주기
      ),
    );
  }
```

GestureDetector위젯에 onLoginTap을 넣어준다

## pushAndRemoveUntil

화면전환하는 메서드인데 뒤로가기를 막는다

```dart
Navigator.of(context).pushAndRemoveUntil(
          MaterialPageRoute(
            builder: (context) => const InterestsScreen(),
          ),
          (route) => false, //false는 이전 route를 모두 유지하고 싶지 않다는 것, true는 이전 route를 모두 유지하므로 뒤로가기가 허용이 된다
        );
```



## GestureDetector

* GestureDetector :

  * onTap: ( ) => 함수 이름(여기서는 onLoginTap(context),

    클릭 됐을 때 그 함수 이름 실행

## Align

stack에 있는 위젯 하나만 정렬하게 해줌

* Align()

  * alignment:
    * Alignment.center

  * child:



## foreground

appbar의 foreground이다

## scaffoldBackgroundColor

main테마에서 전체 배경 색상을 테마로 만들수 있다

## appBarTheme

main테마에서 appBar테마를 만들어줄 수 있다

## titleTextStyle

main테마에서 title Text 테마를 만들 수 있다

## textField()

텍스트를 적을 수 있는 필드이다

## controller 

코드 메서드 등으로 textField와 같은 위젯을 컨트롤 할 수 있다

## AnimatedContainer

애니메이션 컨테이너

## AnimatedDefaultTextStyle

텍스트가 바뀔때마다 애니메이션 효과를 줌

## textButton

텍스트 버튼이다. onPressed를 통해 눌릴때 처리할 콜백 함수를 가질 수 있다

## errorText

textField 안의 decoration에서 에러 메세지를 textfield 바로 아래에 표시할 수 있다

## keyboardType

textField에 있는 keyboardType이다

## onEditingComplete

textfield에 편집이 다 됐을 때

## prefixIcon, prefix

textfield 앞에 아이콘을 넣고 싶을 때,

prefix는 앞에 위젯을 넣고 싶을 때

## suffixIcon, suffix

textfield 뒤에 아이콘을 넣고 싶을 때

suffix는 뒤에 위젯을 넣고 싶을 때 

## obscureText

textfield에서 비밀번호 입력하는것처럼 하기

## enabled

textfield에서 입력 비활성화 시키기

## CuppertinoDatePicker

날짜 선택기를 애플디자인처럼 만듬

## Form

## Formbutton



## TextFormField

4.9 강의 12:39 부터 공부

## Wrap

## CuppertinoButton

애플 스타일 버튼이다

## Scrollbar

스크롤을 해도 사라지지 않는 바를 만들 수 있다

## AnimatedOpacity widget

움직임에 따라 투명도를 조절한다



## TapBarView

tabcontroller 필요

## TabPageSelector

페이지 자동 추적

## AnimatedCrossFade





## bottomNavigationBar

Scaffold안에서 네비게이션 바를 만들 때 사용한다

* bottomNavigationBar

  Material design2의 사양을 따른다

  * BottomNavigationBar()

    * type:

      * BottomNavigationBarType.fixed

      아이템 선택시 애니메이션을 type으로 바꿀 수 있음

    * selectedItemColor

      아이템이 선택 됐을 때, 컬러 변경

    * onTap:

      선택됐을 때, 실행할 함수

      * Items: []

        * BottomNavigationBarItem()

          * icon:

          * label:

          * tooltip:

          * backgroundColor:

            이 아이템이 선택된다면 네비게이션바 색상도 선택한 아이템 색상으로 변경함
  
  * NavigationBar()
  
    Material design3의 사양을 따른다
  
    * labelBehavior: 
  
      * NavigationDestinationLabelBehavior.Show
  
        라벨이 동작에 따라 어떻게 표시되는지 옵션 설정
  
    * selectedIndex:
  
    * destinations: []
  
      bottomNavigationBar의 item역할을 한다
  
      * navigationDestination(icon: ~ ,label:~)
  
        아이콘과 텍스트를 한 아이템으로 만들어준다
  
  * BottomAppBar()
  
    커스텀 앱 바를 만든다
  
    * Color:
    * child:
      * Row나 Col들

bottomNavigationBar는 아이템이 4개 이상일때 배경색이 반전되고, 클릭시 애니메이션 확대가 추가된다

## CupertinoTabbar

애플의 탭바이다. 이를 사용할려면 build 메서드에 Scaffold 대신 CupertinoTabScaffold를 사용해야 한다. Main.dart에도 CupertinoApp으로 바꿔준다

* CupertinoTabScaffold()

  * tabBar

    * CupertinoTabBar()

      * Items: []

        * BottomNavigationBarItem()

          * Icon:

            * Icon(CupertinoIcons.~)

              ios아이콘

          * label

  * tabBuilder : (context, index) => screens[index]

## elementAt

Scaffold안에서 화면을 렌더링할때 사용한다

```dart
final screens = [
  final screens = [
    StfScreen(key: GlobalKey()), //stateful위젯
    StfScreen(key: GlobalKey()),
    Container(),
    StfScreen(key: GlobalKey()),
    StfScreen(key: GlobalKey()),
  ];
]
int _selectedIndex = 0;
  
Scaffold(
	body: screens.elementAt(_selectedIndex) //괄호 안에 숫자 0이면 0번째 스크린, 이렇게만 작성하면 한번에 한 화면만 렌더링한다
)
```

## Offstage

위젯이 안보이게 하면서 계속 존재하게 해준다

## Positioned

stack 내부의 요소를 이동할 수 있게 해줌

* Positioned()

  * child:

  * right: 20

    오른쪽으로 20px 이동시킨다

  * left:20

    왼쪽으로 20px 이동시킨다

  * Top: 등등...

## Positioned.fill

Positioned 처럼 스택 내부의 요소를 이동할 수 있으면서 꽉 채움

* Positioned.fill()
  * child:

## PageView

페이지를 만들수 있다

* PageView

  * pageSnapping: false

    false로 하면 스크롤을 한 만큼만 페이지가 움직인다. true는 살짝만 스크롤 해도 다음 페이지로 넘어간다

  * scroolDirection: Axis.vertical

    스크롤 방향을 vertical로 하면 세로다. 기본값은 가로

  * Children: []



## PageView.builder

ListView.builder처럼 pageview도 빌더를 만들 수 있다

builder메소드는 같은 pageview를 만들지만 children을 동시에 렌더링 하지 않는다

 대신 itembuilder가 있다

* PageView.builder

  * scrollDirection:

  * itemCount: 4

    아이템 개수를 넣어주기

  * Item builder: (context, index) => Container()

    아이템 빌더를 만들어서 전체 렌더링 하지 않게 한다

  * onPageChanged: 함수 이름

    유저가 이동할때 도착하는 페이지에 대한 정보를 주는 메소드

  * controller: 

    페이지 컨트롤러

## PageContoller

PageContoller를 선언해서 페이지를 컨트롤할 수 있다.

```dart
final PageController _pageController = PageController();

//원하는 함수에
_pageController.animateToPage(page,  duration: const Duration(seconds: 5), curve: Curves.~);
  //page는 이동하려는 페이지, duration은 시간, curve는보여주려는 애니메이션 종류
_pageController.nextPage(duration: const Duration(milliseconds: 5), curve: Curves.~); //다음 페이지로 넘어감
```

## VideoPlayer

영상을 틀수 있는 메서드이다

```dart
//video_post.dart 비디오를 불러오는 클래스

import 'package:flutter/material.dart';
import 'package:video_player/video_player.dart';

class VideoPost extends StatefulWidget {
  final Function onVideoFinished; //이 프로퍼티를 추가해주고,
  const VideoPost({
    super.key,
    required this.onVideoFinished,
  });

  @override
  State<VideoPost> createState() => _VideoPostState();
}

class _VideoPostState extends State<VideoPost> {
  final VideoPlayerController _videoPlayerController =
      VideoPlayerController.asset("assets/videos/aa.mp4"); //1. videoplayer선언
  
  @override
  void initState() { //initState만들어주고
    super.initState();
    _initVideoPlayer(); //비디오플레이어 함수를 비동기 함수로 만들어서 선언
  }
  
  @override
  void dispose() { //비디오 플레이어를 초기화 했으면 dispose도 해줘야 한다
    _videoPlayerController.dispose();
    super.dispose();
  }

  void _onVideoChange() { //비디오가 변경 됐을 때
    if (_videoPlayerController.value.isInitialized) { //비디오 컨트롤러가 초기화가 잘 됐는지 확인,
      if (_videoPlayerController.value.duration ==
          _videoPlayerController.value.position) { //비디오플레이어의 영상 길이가 현재 영상 위치랑 같은지(영상의 끝에 도달 했는지)
        widget.onVideoFinished(); //도달했다면 영상을 끝냄(VideoTimelineScreen 클래스에서 호출된 메서드 onVideoFinished를 호출)
      }
    }
  }

  void _initVideoPlayer() async {
    await _videoPlayerController.initialize(); //비디오플레이어 초기화
    _videoPlayerController.play(); //비디오플레이어 실행 
    setState(() {});
    _videoPlayerController.addListener(_onVideoChange); //비디오플레이어의 이벤트리스너를 만든다. 영상이 시작되거나, 끝나거나, 시간 등등, 그리고 함수를 안에 넣어줌(_onVideoChange)
  }



  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        Positioned.fill(
          child: _videoPlayerController.value.isInitialized
              ? VideoPlayer(_videoPlayerController)
              : Container(
                  color: Colors.black, //videoPlayer가 불러와졌다면 container를 보여주지 말고 영상을 보여준다
                ),
        ),
      ],
    );
  }
}


//video_timeline_screen.dart 비디오 화면 자체를 나타내는 class
import 'package:flutter/material.dart';
import 'package:tiktok_clone/features/videos/widgets/video_post.dart';

class VideoTimelineScreen extends StatefulWidget {
  const VideoTimelineScreen({super.key});

  @override
  State<VideoTimelineScreen> createState() => _VideoTimelineScreenState();
}

class _VideoTimelineScreenState extends State<VideoTimelineScreen> {
  int _itemCount = 4;

  final PageController _pageController = PageController();

  final _scrollDuration = const Duration(milliseconds: 250);
  final _scrollCurve = Curves.linear;

  void _onPageChanged(int page) {
    _pageController.animateToPage(
      page,
      duration: _scrollDuration,
      curve: _scrollCurve,
    );
    if (page == _itemCount - 1) {
      _itemCount = _itemCount + 4;

      setState(() {});
    }
  }

  void _onVideoFinished() { //비디오가 끝나면 이 메서드를 호출, 다음 비디오로 넘기는 메서드
    _pageController.nextPage(
      duration: _scrollDuration,
      curve: _scrollCurve,
    );
  }

  @override
  void dispose() {
    _pageController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return PageView.builder(
      controller: _pageController,
      scrollDirection: Axis.vertical,
      onPageChanged: _onPageChanged,
      itemCount: _itemCount,
      itemBuilder: (context, index) =>
          VideoPost(onVideoFinished: _onVideoFinished), //itembuilder에게 onVideoFinished 프로퍼티에 그 기능을 하는 함수를 넣어줘서 비디오가 끝나면 함수가 실행되도록 한다. videoPost클래스로 가서 onVideoFinished 프로퍼티를 만들어준다
    );
  }
}

```

## VisibilityDetector

사용자가 완전히 스크롤을 내리고 난 다음에 재생

* VisibilityDetector

  * key:Key("$widget.index"),

  * onVisibilityChanged: _onVisibilityChanged

    ```dart
      void _onVisibilityChanged(VisibilityInfo info) {
        if (info.visibleFraction == 1 && !_videoPlayerController.value.isPlaying) { //현재화면이 100% 다 보이고, 비디오가 재생중이 아니면
          _videoPlayerController.play(); //비디오 재생
        } 
    ```

    

  * Child:

  

## IgnorePointer



## AnimationController

```dart
late final AnimationController _animationController;

//원하는 곳에 가서 
_animationController = AnimationController(vsync: vsync)
```

initState에서 설정해주는 방법1

```dart
 @override
  void initState() {
    super.initState();
    _initVideoPlayer();

    _animationController = AnimationController(
      vsync: this,
      lowerBound: 1.0,
      upperBound: 1.5,
      value: 1.5,
      duration: _animationDuration,
    );
    _animationController.addListener(() { //이벤트리스너 추가
      setState(() {}); //build가 알아차리게 하기
    });
  }

void _onTogglePause() {
    if (_videoPlayerController.value.isPlaying) {
      _videoPlayerController.pause();
      _animationController.reverse(); //upperBound에서 lowerBound로
    } else {
      _videoPlayerController.play();
      _animationController.forward(); //lowerBound에서 upperBound로
    }

    setState(() {
      _isPaused = !_isPaused;
    });
  }

//이제 애니메이션 적용할 곳에
Positioned.fill(
            child: IgnorePointer(
              child: Center(
                child: Transform.scale(
                  scale: _animationController.value, //이렇게 적용
                  child: AnimatedOpacity(
                    opacity: _isPaused ? 1 : 0,
                    duration: _animationDuration, 
                    child: const FaIcon(
                      FontAwesomeIcons.play,
                      color: Colors.white,
                      size: Sizes.size52,
                    ),
                  ),
                ),
              ),
            ),
          )
```

방법2

방법은 거의 같고 build가 알아차리게 하는 방법 차이다

## AnimatedBuilder

build 메서드에서 AnimatedBuilder를 추가함. 그리고 그 애니메이션이 있는 stateful class에게 상속을 시켜준다

```dart
class _VideoPostState extends State<VideoPost> with SingleTickerProviderStateMixin
```



```dart
@override
  Widget build(BuildContext context) {
    return VisibilityDetector(
      key: Key("${widget.index}"),
      onVisibilityChanged: _onVisibilityChanged,
      child: Stack(
        children: [
          Positioned.fill(
            child: _videoPlayerController.value.isInitialized
                ? VideoPlayer(_videoPlayerController)
                : Container(
                    color: Colors.black,
                  ),
          ),
          Positioned.fill(
            child: GestureDetector(
              onTap: _onTogglePause,
            ),
          ),
          Positioned.fill(
            child: IgnorePointer(
              child: Center(
                child: AnimatedBuilder( //이걸 추가함
                  animation:
                      _animationController, //이 값이 변할 때마다 return Transform.scale함
                  builder: (context, child) {
                    return Transform.scale(
                      scale: _animationController.value,
                      child: child, //밑의 child를 받아온다
                    );
                  },

                  child: AnimatedOpacity(
                    opacity: _isPaused ? 1 : 0,
                    duration: _animationDuration,
                    child: const FaIcon(
                      FontAwesomeIcons.play,
                      color: Colors.white,
                      size: Sizes.size52,
                    ),
                  ),
                ),
              ),
            ),
          )
        ],
      ),
    );
  }
```





## SingleTickerProviderStateMixin

ticker는 매 프레임마다 callback을 호출함(build함)

SingleTickerProviderStateMixin는 현재 보여지는 화면만 ticker를 실행하게 해줌

## TickerProviderStateMixin

애니메이션 controller가 여러개 있을땐  TickerProviderStateMixin을 사용하면 된다

## circleAvatar

원에 사진이나 텍스트를 넣을 수 있다

* circleAvatar
  * radius : 25
  * Child:

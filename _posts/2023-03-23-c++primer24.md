---
layout: single
title: "C++ primer 24"
categories: C++_primer
tags: [c++]
author_profile: false
#search: false
---

## string 스트림

istringstream 타입에서는 string을 읽고, ostringstream은 string에 기록 하며 stringstream은 string을 읽고 쓴다.

fstream 타입처럼 sstream타입에서 정의한 타입 역시 iostream 헤더에서 사용한 타입을 상속받는다. 상속받은 연산과 더불어 sstream에서 정의한 타입에는 스트림과 연관 지은 string을 관리하는 멤버도 있다.

fstream과 sstream에서는 iostream에 대한 인터페이스를 공유하지만 둘 사이에 다른 관계는 없음에 주의한다. 특히 open과 close는 stringstream에 쓸 수 없을 뿐만 아니라 str은 fstream에 쓸 수 없다.

|      표현식      |                             설명                             |
| :--------------: | :----------------------------------------------------------: |
|  sstream strm;   | strm은 결합하지 않은 stringstream이며, sstream은 sstream 혜더에서 정의한 타입 중 하나이다 |
| ssrream strm(s); | strm은 string s의 복사본을 담고 있는 sstream이다.<br/> 이 생성자는 explicit(7.5.4절)이다. |
|    strm.str()    |         strm에서 담고 있는 string 복사본을 반환한다.         |
|   strm.str(s)    |       string s를 strm에 복사해 넣는다. void를 반환한다       |

### istringstream 사용하기 

istringstream은흔히 한줄 내용 전체에 대해, 줄 내 개별 단어를 사용해 처리할때 사용한다

예를 들면

파일 내 각 레코드는 이름으로 시작하며 그다음에 전화번호가 하나 이상 있다. 먼저 입력 데이터를 나타내는 간단한 클래스를 정의한다.

```c++
//가본적으로 멤버는 public 이다. 7.2절을 참조한다 
struct PersonInfo {
	string name;
	vector<string> phones;
};
```

프로그램에서는 데이터 파일을 읽고 PersonInfo의 vector를 구성하는데, vector 내 각 요소는 파일 내 레코드 하나에 대응한다. 루프에서 레코드를 읽어 입력 내용을 처리한 다음 각 개인별 이름과 전화번호를 끄집어 낸다.

```c++
string line, word; // 줄과 단어를 입력에서 하나씩 읽어 담는다 
vector<PersonInfo> people; //입력에서 읽은 전체 레코드를 담는다
// cin이 파일끝에 도달(하거나 다른 오류가 발생)할 때까지 한 번에 한 줄씩 입력을 읽는다 
while (getline(cin, line)) {
	PersonInfo info; // 현재 레코드의 데이터를 담을 객체를 생성한다 
  istringstream record(line); // record를 방금 읽은 line과 결합한다 
  record >> info.name; // 이름을 읽는다
	while (record >> word) // 전화번호를 읽는다
		info.phones.push_back(word); // 전화번호를 저장한다 
  people.push_back(info); // 현재 레코드를 people에 추가한다
}
```

### ostringstream 사용하기

ostringstream은 출력할 내용을 차례로 만들어 가지만 출력은 나중에 해야 할 때 유용하다. 예를 들어 앞 예제에서 읽은 전화번호가 유효한지 확인하고 서식을 다시 맞춰야할수 있다. 모든 번호가 유효하면 서식을 다시 맞춘 번호를 담고 있는 새 파일을 출력하려 한다. 유효하지 않은 번호가 있으면 그 번호는 새 파일에 넣지 않고 해당 개인의 이름과 유효하지 않은 번호 목록을 담고 있는 오류 메시지를 기록한다. 

유효하지 않은 번호가 있는 개인에 대해서는 어느 데이터도 포함하지 않았으면 하므로 그 개인의 번호가 모두 유효한지 확인하기 전까지는 내용을 출력할 수 없다. 하지만 그 출력 내용을 메모리 상에 존재하는 ostringstream에 ‘기록'할 수 있다.

```c++
for (const auto &entry : people) 
{ // people의 각 entry에 대해  
	ostringstream formatted, badNums; // 매 루프마다 생성하는 객체
	for (const auto &nums : entry.phones) 
  { // 각 번호에 대해
		if (!valid(nums)) {
		badNums << " " << nums ; // badNurns의 string 또는
		} else
  	// formatted의 string에 ‘기록 한다 
  	formatted << " " << format(nums);
  }
	if (badNums.str().empty()) // 잘못된 번호가 없다 
  	os << entry.name << " " 
			<< formatted.str() << endl; // 이름과 서식을 다시 맞춘 번호를 출력한다
	else // 아니면 이름과 잘못된 번호를 출력한다 
  	cerr << "input error: " << entry.name
			<< " invalid number (s) " << badNums.str () << endl;
 }
```

# 순차 컨테이너

컨테이너에서는 특정 타입의 객체 모음을 담는다. 프로그래머는 순차 컨테이너를 사용해 요소를 저장하고 접근하는 순서를 제어할 수 있다. 순서 있는 또는 순서 없는 연관 컨테이너 는 키 값을 바탕으로 요소 를 저장한다 

또한 라이브러리에서는 세 가지 컨테이너 어댑터도 제공하는데 각각 에서는 컨테이너 연산에 대한 다른 인터페이스를 정의해 컨테이너 타입을 변형한다. 어댑터는 이 장 마지 막에서 다룬다.

## 순차 컨테이너 개관

모든 순차 컨테이너에서는 자신의 요소를 순차적으로 빠르게 접근할 수 있다. 이런 컨테이너는 컨테이너에 요소를 추가하거나 삭제하는 비용이나 컨테이너 요소에 비순차적으로 접근하는 비용에서 성능의 균형점이 서로 다르다.

|     종류     |                             기능                             |
| :----------: | :----------------------------------------------------------: |
|    vector    | 가변 크기 배열 빠른 임의 접근을 지원한다.<br/> 끝 이외에서 요소를 삽입하거나 삭제하면 느릴 수 있다. |
|    deque     | 끝이 양쪽인 큐double-endedqueue. 빠른 임의 접근을 지원한다.<br/>처음 또는 끝에서 삽입/삭제가 빠르다. |
|     list     | 이중 연결 리스트. 양방항 순차 접근만 지원한다.<br/> list 내 모든 지점에서 삽입/삭제가 빠르다. |
| forward list | 단일 연결 리스트. 단방향 순차 접근만 지원한다.<br/> 리스트 내 모든 지점에서 삽입/삭제가 빠르다. |
|    array     | 고정 크기 배열 빠른 임의 접근을 지원한다.<br/> 요소를 추가하거나 제거할 수 없다. |
|    string    | 문자를 담는 특별한 컨테이너이며 vector와 비슷하다. <br/>빠른 임의 접근. 끝에서 삽입/삭제가 빠르다. |

#### 사용할 순차 컨테이너 결정하기

다른 컨테이너를 선호하는 특별한 이유가 없으면 일반적으로 vector를 사용하는 것이 가장 좋다.

사용할 컨데이너를 선택할 때 다음 원칙을 기준으로 삼을 수 있다.

* 다른 컨테이너를 사용할 이유가 없으면 vector를 사용한다.

* 프로그램에 크기가 작은 요소가 많고 공간에 대한 부담이 종요하다면 list나 forward_list는 사용하지 않는다.

* 프로그램에서 요소에 임의 접근을 해야 하면 vector나 deque를 사용한다.

* 프로그램에서 컨테이너 가운데에 요소를 삽입하거나 삭제해야 하면 list나forward_list를 사용한다.

* 프로그램에서 처음과 끝에서만 요소를 삽입하거나 삭제하고 가운데에서는 하지 않는다면 deque를 사용한다.

* 프로그램에서 입력을 읽는 동안에만 컨테이너 가운데에 요소를 삽입하고 그 이후에는 요소에 임의 접근해야 하면 

  —먼저 실제로 컨테이너 가운데에 요소를 추가해야 하는지 결정한다. 입력을 마쳤을 때 컨테이너 내용을 재정렬하기 위해 vector에 추가한 다음 sort 함수(10.2.3절에서 다룬다)를 호출하는 것이 대개 더 쉽다.
   -반드시 가운데에 삽입해야 하면 입력하는 동안에는 list 사용을 고려한다. 입력을 마치면 list를 복사해 vector에 넣는다.

## 컨테이너 라이브러리 개관

이 절에서는 모든 컨데이너에 공통인 부분만 다루고 이 장 나머지에서는 오로지 순차 컨테이너에만 집중한댜 연관 컨테이너 전용 연산은 11장에서 다룬다.

일반적으로 각 컨테이너는 해당 타입과 같은 이름인 헤더 파일에 정의한다. 즉 deque는 deque 헤더, list는 list 헤더에 정의하는 식이다. 컨테이너는 클래스 템플릿(3.3절)이므로 vector처럼 특정 컨테이너 타입을 생성하려면 추가 정보를 지정해야 한다. 전부는 아니지만 컨테이너 대부분에서 이 정보는 요소 타입이다.

```c++
list<Sales_data> // Sales_data 객체를 담는 list 
deque<double> // double을 담는 deque
```

#### 컨테이너에 담을 수 있는 타입에 대한 제약

거의 모든 타입을 순차 컨테이너 요소 타입으로 사용할 수 있다. 특히 다른 컨테이너 자체를 요소 타입으로 하는 컨테이너도 정의할 수 있는데 이런 컨테이너 역시 다른 컨테이너 타입과 동일한 방식으로 정의한다. 즉 꺾쇠 괄호 안에 요소 타입을 지정한다.

```c++
vector<vector<string>> lines ; // vector의 vector
```

거의 모든 타입을 컨테이너에 저장할 수 있지만 일부 컨테이너 연산은 요소 타입에서 그 연산 조건을 만족해야 쓸 수 있다. 연산별 조건을 지원하지 않는 타입에 대해 컨테이너를 정의할 수 있지만 연산은 요소 타입이 해당 연산 조건과 일치할 때만 쓸 수 있다.

 일부 클래스에는 기본 생성자가 없다. 이런 타입 객체를 담는 컨테 이너를 정의할 수 있지만 요소 개수만 사용해서는 그런 컨데이너를 생성할 수 없다.

```c++
//noDefault는 기본 생성자가 없는 타입으로 가정한다
vector<noDefault> v1 (10,init) ; //좋음 : 요소 초기 값을 지정했다
vector<noDefault> v2 (10) ; //오류: 요소 초기 값을 반드시 지정해야 한다
```

표: 컨테이너 연산

|                          표현식                          |                             내용                             |
| :------------------------------------------------------: | :----------------------------------------------------------: |
|                        타입 별칭                         |                             ---                              |
|                         iterator                         |               컨테이너 타입에 대한 반복자 타입               |
|                      const iterator                      |      해당 요소를 읽기만 하고 변경할 수 없는 반복자 타입      |
|                        size_type                         | 해당 컨테이너 타입의 가능한 가장 큰 컨테이너 크기를 담기에 충분히 큰부호없는 정수 타입 |
|                     difference_type                      | 두 반복자 사이의 거리를 담기에 충분히 큰 부호 있는 정수 타입 |
|                        value_type                        |                           요소타입                           |
|                        reference                         |         요소의 좌변 값 타입이며 value_type&와 동의어         |
|                     const reference                      |       요소의 canst 좌변 값 타입(측 canst value_type&)        |
|                           생성                           |                             ---                              |
|                           C c;                           |         기본 생성자, 빈 컨테이너(array, 397쪽 참조)          |
|                        C c1(c2);                         |                 c2 복사본으로 c1을 생성한다                  |
|                        C c(b,e) ;                        | 반복자 b와 e로 나타내는 범위의 요소를 복사한다(array에는 유효하지 않다) |
|                     C c{a,b,C ...};                      |                     e를 목록 초기화한다                      |
|                       대입과 swap                        |                             ---                              |
|                         c1 = c2                          |                c1의 요소를 c2 것으로 교체한다                |
|                      c1={a'b'C ...}                      | cl의 요소를 목록에 있는 것으로 교체한다(array에는 유효하지 않다) |
|                        a.swap (b)                        |                요소를 b에 있는 것과 교환한다                 |
|                        swap(a, b)                        |                       a.swap(b)와 같다                       |
|                           크기                           |                             ---                              |
|                        c .size()                         |         c의 요소 수(forward list에는 유효하지 않다)          |
|                       c.max size()                       |               c에서 담을 수 있는 최대 요소 수                |
|                        c.empty()                         |             c에 요소가 있으면 false, 없으면 true             |
|         요소 추가/삭제(array에는 유효하지 않다)          | (참고 : 이 연산에 대한 인터페이스는 컨테이너 타입에 따라 다르다) |
|                      c.insert(args)                      |            args로 지정한 요소를 복사해 c에 넣는다            |
|                     c.emplace(inits)                     |              inits를 사용해 c의 요소를 생성한다              |
|                      c.erase(args)                       |                args로 지정한 요소를 제거한다                 |
|                        c.clear()                         |          c에서 모든 요소를 제거하며 void를 반환한다          |
|                     상등과관계 연산                      |                             ---                              |
|                          ==, !=                          |             상등은 모든 컨테이너 타입에 유효하다             |
|                       <, <=, >, >=                       |     관계 연산(순서 없는 연관 컨테이너에는 유효하지 않다)     |
|                        반복자얻기                        |                             ---                              |
|                   c.begin() , c.end()                    | c의 처음과 마지막 요소 바로 다음 위치에 대한 반복자를 반환한다 |
|                 c.cbegin () , c.cend ()                  |                  const_iterator를 반환한다                   |
| 가역 컨테이너의 추가멤버(forward_list에는 유효하지 않음) |                             ---                              |
|                     reverse iterator                     |           역방향으로 요소를 가리킬 수 있는 반복자            |
|                  const_reverse_iterator                  |             요소에 기록할 수 없는 역방향 반복자              |
|                  c.rbegin() , c.rend()                   | c의 마지막과 첫 요소 바로 다음 워치에 대한 반복자를 반환한다 |
|                 c.crbegin() , c.crend()                  |              const_reverse_iterator를 반환한다               |

### 반복자

컨테이너처럼 반복자에도 공통 인터페이스가 있다.

예를 들면 표준 컨테이너 타입에 대한 반복자는 모두 컨테이너 요소에 접근할 수 였는데 이를 위해 모든 반복자에서 역참조 연산자를 제공한다. 마찬가지로 라이브러리 컨데이너에 대한 반복자는 모두 한 요소에서 다음으로 이동하는 증가 연산자를 정의한다.

 forward_list 반복자에서 감소(--) 연산자를 지원하지 않는다는 것이다. 표 3.7에 있는 반복자 산술 연산은 string, vector, deque, array에 대한 반복자에 만 적용하며 그 외 다른 컨데이너 타입에 대한 반복자에는 사용할 수 없다.

#### 반복자 범위

반복자 범위는 같은 컨테이너에 속한 요소 또는 마지막 요소 바로 다음 위치를 참조하는 각 반복자의 쌍으로 나타낸다.

이러한 두 반복자는 흔히 begin과 end 또는(다소 오해하기 쉽게) first와 last로 언급하며 컨테이너 에서 요소의 범위를 표시한다.

이 요소 범위를 좌 포함 구간이라 한다 이 범위에 대한 표준 수학 표기는

 [ begin, end )

이며 범위는 begin에서 시작해 end로 마치는데 end는 포함하지 않음을 나타낸다. 반복자 begin과 end에서는 반드시 같은 컨테이너를 참조해야 한다. 반복자 end는 begin과 같을 수 있으나 반드시 begin으로 나타내는 요소보다 앞의 것을 참조하면 안 된다.

#### 좌 포함 범위에 내포된 의미를 사용해 프로그래밍하기

라이브러리에서 좌포함 범위를 사용하는 것은 다음 세 가지 특징 때문이다.

* begin이 end와 같으면 그 범위는 비었다.
* begin이 end와 다르면 그 범위에 요소가 적어도 하나 있고 begin은 해당 범위의 첫 요소를 참조한다.
* being == end일 때까지 몇 번이고 begin을 증가시킬 수 있다.

이러한 특징은 어떤 범위의 요소를 처리하기 위해 다음과 같은 루프를 안전하게 만들 수 있음을 뜻한다

```c++
while (begin != end) {
	*begin = val; // 좋음 : 범위가 비어 있지 않으므로 begin은 요소를 나타낸다 
	++begin; // 다음 요소를 얻기 위해 반복자를 증가시킨다
}
```

주어진 begin과 end에서 반복자 범위를 형성하는데, begin == end이면 그 범위가 비어 있으므로 이 경우에는 루프를 빠져나간다. 범위가 비어 있지 않으면 begin에서 이 범위의 요소를 참조하므로 while 본체 안에서 begin을 역참조해도 안전하다. 마지막으로, 이 루프 본체에서는 begin을 증가시키므로 결국에는 이 루프를 종료한다.

### 컨테이너 타입 멤버

각 컨테이너에서는 표 9.2에 있는 여러 타입을 정의한다. 컨테이너에서 정의한 타입 중 size_type(3.2.2절), iterator,const_iterator(3.4.1절)세가지는 이미 사용했다 컨데이너 대부분에서는 이미 사용한 반복자 타입에 추가로 역방향 반복자도 제공한다. 예를 들어 역방향 반복자에 ++를 적용하면 이전 요소를 반환한다.

나머지 타입 별칭으로는 컨테이너에 저장한 요소의 타입이 무엇인지 몰라도 그 타입을 사 용할 수 있댜 요소 타입이 필요하면 해당 컨테이너의 value_type을 참조하고, 요소 타입 에 대한 참조자는 reference나 const_reference를 사용해 얻는다.

```c++
// iter는 list<string>에서 정의한 iterator 타입이다
list<string>::iterator iter;
// count는 vector<int>에서 정의한 difference_type 타입이다 
vector<int>::difference_type count;
```

```c++
//이 선언에서는 범위 연산자(1.2절)를 사용해 각각 list<string> 클래스의 iterator 멤버와 vector<int>에서 정의한 difference_type을 원함을 나타낸댜
```

### begin과 end 멤버

begin과 end 연산(3.4.1절)에서는 컨데이너에서 처음과 마지막 요소 바로 다음 위치를 참조하는 반복자를 반환한댜 이 반복자는 해당 컨테이너의 모든 요소를 포함하는 반복자 범위를 형성하는데 거의 항상사용한다.

begin과 end에는 여러 버전이 있는데 r이 있는 버전에서는 역방 향 반복자를 반환한다. 

c로 시작하는 버전에서는 연관된 반복자의 const 버전을 반환한다.

```c++
list<string> a = {"Milton", "Shakespeare", "Austen"};
auto itl = a.begin(); // list<string>::iterator
auto it2 = a.rbegin (); // list<string>::reverse_iterator 
auto it3 = a.cbegin(); // list<string>::const_iterator
auto it4 = a.crbegin(); // list<string>::const_reverse_iterator
```

c로 시작하지 않는 함수는 다중 정의한 것이다. 즉 실제로는 이름이 begin인 멤버가 둘인 데 하나는 컨테이너의 const_iterator 타입을 반환하는 const 멤버이고 다 른 하나는 const가 아닌 멤버로 컨테이너의 iterator 타입을 반환한다
rbegin, end, rend도 마찬가지이다. 이 멤버 중 하나를 const가 아닌 객체에서 호출하면 iterator를 얻으며, 이 멤버를 const 객체에서 호출할 때에만 const 버전 iterator 를 얻는다 const에 대한 포인터와 참조자처럼 보통의 iterator를 그에 해당하는 const_iterator로 변환할 수 있지만 역으로는 할 수 없다.

auto를 begin이나 end와 함께 사용할 때 얻는 반복자 타입은 컨테이너 타입에 따르며 반복자의 사용 의도와는 무관하다. c 버전을 사용하면 컨테이너 타입에 관계없이 const_iterator를 얻는다.

### 컨테이너를 정의하고 초기화하기

모든 컨테이너 타입에서는 기본 생성자(7.1.4절)를 정의한댜 arrary는 예외지만 기본 생 안; 성자에서는 지정한 타입으로 빈 컨테이너를 생성한다.

#### 다른 컨테이너의 복사본으로 컨테이너 초기화하기

다른 컨테이너의 복사본으로 새 컨데이너를 생성하는 방법에는 두 가지가 있다. 

즉 컨테이너를 직접 복사하거나, (arrary는 예외지만) 반복자 쌍으로 나타낸 요소 범위를 복사할 수 있다.

다른 컨테이너 복사본으로 컨테이너를 생성하려면 컨테이너와 요소 타입이 반드시 일치 해야한다. 하지만반복자를 전달할 때는 컨테이너 타입이 동일하지 않아도 된다. 게다가 복사하려는 요소를 초기화할 컨테이너의 요소 타입으로 변환(4.11절)할 수 있으면 새 컨테이너와 원래 컨터이너의 요소 타입은 다를 수 있다.

```c++
//각 컨테이너에는 세 요소가 있으며 지정한 초기 값으로 초기화한다
list<string> authors = {"Milton", "Shakespeare", "Austen"};
vector<const char*> articles = {"a", "an", "the"};
list<string> list2 (authors); //좋음 : 타입이 일치한다 
deque<string> authList(authors);//오류 : 컨테이너 타입이 일치하지 않는다
vector<string> words(articles);//오류 : 요소 타입이 반드시 일치해야 한다

//좋음 : const char* 요소를 string으로 변환한다
forward_list<string> words(articles.begin() , articles.end());
```

두 반복자를 취하는 생성자에서는 복사하려는 요소 범위를 나타내기 위해 그 반복자를 사용한다 일반적으로 그 반복자에서는 복사하려는 첫 요소와 마지막 요소 바로 다음 위치를 표시한다. 새로운 컨테이너는 이 범위에 속한 요소 수와 크기가 같으며, 새로운 컨테이너에서 각 요소는 이 범위의 해당 요소 값으로 초기화한다.

반복자에서 범위를 나타내므로 이 생성자를 사용해 컨테이너의 부분 순차열을 복사할수있다. 예를 들어 it를 authors에서 요소를 나타내는 반복자라고 하면 다음처럼 쓸 수 있다

```c++
//it로 나타내는 요소 직전까지 복사한다
deque<string>authList(authors.begin(),it);
```



표9.3 넣기

|                            표현식                            |                             내용                             |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
|                             C c;                             | 기본 생성자. C가 array이면 c의 요소는 기본 초기화하며 그렇지 않으면 c는 비어 있다. |
|                    C c1(c2)<br/>C c1 = c2                    | cl은 c2의 복사본이다 cl과 c2는 같은 타입(측 컨테이너 타입이 같아야 하고 담고 있는 요소 타입이 같아야 한다. 또한 array인 경우 크기도 같아야 한다)이어야 한다 |
|             C c{a,b,c,...}<br/>C c = {a,b,c,...}             | c는 초기값 목록의 요소 복사본이다.목록의 요소 타입은 C의요소 타입과 호환되어야 한다. array인 경우 목록의 요소 수는 반드시 해당 array 크기와 같거나 적어야 하며, 모자란 요소는 값 초 71화(3.3.1절)한다. |
|                           C c(b,e)                           | c는 반복자 b와 e로 나타내는 범위의 요소 복사본이다. 요소타입 은 반드시 C의 요소 타입과 호환되어야 한다. (array에는 유효하지않다) |
| 크기를 취하는 생성자는 {array를 제외한} 순차 컨테이너에서만 유효하다 |                             ----                             |
|                           C seq(n)                           | seq에는 값 초기화한 요소가 n개 있으며 이 생성자는 explicit(7.5.4절)이다. (string에는 유효하지 않다.) |
|                          C seq(n,t)                          |               seq에는 값이 t인 요소가 n개 있다               |


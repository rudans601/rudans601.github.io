---
layout: single
title: "C++ primer 15"
categories: C++_primer
tags: [c++]
author_profile: false
#search: false
---

### do while 문

do while문은 while과 비슷하지만 본체를 실행한 후에 조건을 확인하므로 조건에 관계 없이 루프를 적어도 한번 실행한다.

do

{

​	문장

}while(조건);

do while은 괄호로 둘러싼 조건 다음에 세미콜론으로 마친다. 조건이 false이면 루프를 마치고, 그렇지 않으면 루프를 반복한다. 

문장 또는 구역을 실행할 때까지 조건을 평가 하지 않으므로 do while루프에서는 조건 내에서 변수 정의를 할 수 없다

```c++
do
{
   //....
   mumble(foo);
}while (int foo = get_foo()); //오류: do 조건에서 선언했다
```

## 분기문

분기문은 실행 흐름을 가로챈다. c++에는 break, continue, goto, return이 있다.

### break문

break는 가장 가까이에서 둘러싸고 있는 while, do while, for, switch문을 종료한다. 실행은 종료한 문장 바로 다음 문장에서 계속한다

break는 반복문이나 switch 문 안에서만 사용할 수 있다.

```c++
string buf;
while (cin >> buf && !buf.empty())
{
    switch(buf[0])
    {
        case '-':
            for(auto it = buf.begin() + 1; it != buf.end(); ++it)
            {
                if(*it == ' ')
                    break; // #1 제어 루프를 빠져나간다
            }
            //break #1에서는 여기로 제어를 옮긴다
            break; // #2, switch문을 빠져나간다
        case '+':
            //...
    }
    //break #2에서는 여기로 제어를 옮긴다
}
```

### continue문

continue문에서는 가장 가까이에서 둘러싸고 있는 루프의 현재 반복을 종료하고 즉시 다음 반복을 시작한다 continue는 for,while,do while루프 그리고 이런 루프 안에 중첩된 문장이나 구역을 포함한 안에서만 쓸 수 있다. 

continue는 현재 반복을 가로채므로 실행은 루프 내에 머무른다. while이나 do while에서는 조건을 평가해 실행을 계속하고 for루프에서는 for헤더 내 표현식에서 실행을 계속한다. 범위 for에서는 제어 변수를 순차열의 다음 요 소로 초기화해 실행을 계속 한다.

### goto문

goto문을 사용하면 해당 goto에서 같은 함수 내 문장으로 무조건 분기를 할 수 있다. 하지만 그만 알아보도록 하자...

## try 구역과 예외 처리

예외는 정상적인 프로그램 기능에서 벗어난 실행중 발생하는 이상 현상이다. 일반적으로 예외 처리는 프로그램 한 부분에서 자체적으로 해결할 수 없는 문제를 감지하고 그 문제가 감지부에서 계속해서 프로그램을 실행할 수 없는 것일때 사용한다.

이런 경우 문제를 발견한 부분에서는 어떤 일이 발생했으며 계속해서 실행할 수 없음을 알릴 방법이 있어야 한다. 게다가 프로그램 어느 부분에서 그 예외 조건을 처리할 것인지 몰라도 문제를 알릴 수 있어야 한다. 어떤 일이 발생했는지 알리고 문제를 발견한 부분은 처리를 멈춘다.

예외 처리는 다음과 같다

* throw 표현식 : 감지부에서 처리할 수 없는 무언가를 만났음을 나타내는 데 사용한다. 이때 throw에서 예외를 일으킨다라고 한다.
*  try 구역 : 처리부에서 예외를 처리하는 데 사용한다. try 구역은 try 키워드로 시작하고 하나 이상인 catch 절로 마친다. try 구역 안에서 실행한 코드에서 발생한 예외는 일반적으로 여러 catch 절 중 하나에서 처리한다. catch 절에서는 예외를 처리하므로 예외 처리자 라고도 한다.
* exception 클래스 집합 : 발생한 것에 대한 정보를 throw와 연관된 catch 사이에 전달하는데 사용한다. 또한 예외에 대해서는 18.1절에서 더 얘기 하기로 한다.

### throw 표현식

프로그램 감지부에서는 throw 표현식을 사용해 예외를 일으킨다 throw는 throw 키워드와 그 다음에 오는 표현식으로 구성하는데, 이 표현식의 타입으로 발생하는 예외 종류를 결정한다. throw 표현식에는 일반적으로 표현식 문장임을 나타내는 세미콜론을 붙인다.

```c++
if (item1.isbn() != item2.isbn())
    throw runtime_error("Data must refer to same ISBN");
cout << item1 + item2 << endl;
```

이 예에서는 런타임 에러 타입 객체인 표현식을 던진다. 예외를 발생시키면 현재 함수를 마치고 이 오류를 처리할 수 있는 처리자로 제어를 옮긴다. 

runtime_error 타입은 예외 타입 표준 라이브러리이며 stdexcept 헤더에서 정의한다. runtime_error는 string또는 c형식 문자열을 사용해 초기화 해야 하며, 이 문자열로 문제에 대한 추가 정보를 제공한다.

### try 구역

try 구역의 일반적인 형식은 다음과 같다

try{

​	프로그램-문장

} catch ( 예외 - 선언) {

​	처리자-문장

} catch (예외 - 선언) {

​	처리자-문장

} //...

try구역은 try 키워드로 시작하고 그 다음에 일반적으로 중괄호로 둘러싼 일련의 문장인 구역이 온다 try 구역 다음에는 하나 이상인 catch 절 목록이 온다. catch는 catch 키워드, 괄호 안에 있는 객체의 선언(이를 예외 선언 이라고 한다) 그리고 구역 이렇게 세 부분으로 구성한다. 예외를 처리할 catch를 선택하면 관련 구역을 실행하며 catch를 마치면 해당 try 구역의 마지막 catch 절 바로 다음 문장을 계속 실행한다.

try 구역 안에서 정의한 변수는 구역 밖으로 특히 catch 절로 접근할 수 없다

#### 처리자 만들기

```c++
while (cin >> item1 >> item2)
{
    try
    {
        //두 Sales_item을 더하는 코드를 실행한다
        //덧셈을 실패하면 이 코드에서는 runtime_error 예외를 발생한다
    }
    catch (runtime_error err)
    {
        //ISBN이 일치해야 함을 사용자에게 상기시키고 다른 쌍을 입력하도록 알린다
        cout << err.what() << "\n try again? Enter y or n" << endl;
        char c;
        cin >> c;
        if(!cin || c == 'n')
            break; //while 루프를 빠져나간다
    }
}
```

#### 처리자를 찾는 동안 함수를 빠져나간다

여러 try 구역이 중첩된 구역을 지나갈 수도 있다. 처리자 검색은 연속적인 함수 호출과 반대이므로 예외가 발생하면 그 예외를 발생한 함수를 가장 먼저 찾는다. 일치하는 catch를 찾을 수 없으면 그 함수를 빠져나오고, 예외를 발생한 함수를 호출한 함수를 다음으로 찾는다. 처리자를 찾지 못하면 이 함수 역시 빠져나간 후 이 함수를 호출한 함수를 다음으로 찾으며 이런 식으로 적합한 타입의 catch를 찾을 때까지 실행 경로를 거슬러 간다.

적합한 catch를 찾지 못하면 terminate 라이브러리 함수로 실행을 옮기는데 이 함수는 시스템에 따라 다르긴 하지만 프로그램을 더이상 실행하지 않고 중단함을 보장한다.

try구역을 정의하지 않은 프로그램에서 발생한 예외 역시 같은 방법으로 처리한다. 어쨌든 try 구역이 없으면 처리자도 있을 수 없다. try구역이 없는 프로그램에서 예외가 발생하면 terminate를 호출하게 되고 프로그램을 종료한다.

### 표준 예외

c++ 라이브러리에서는 표준 라이브러리 함수에서 문제가 생겼을 때 이를 보고하는 데 사용하는 여러 클래스를 정의한다. 

* exception 헤더에서는 가장 일반적인 예외 클래스인  exception을 정의한다. 이는 예외가 발생한 것만 알리며 다른 추가 정보는 제공하지 않는다.
* stdexcept 헤더에서는 몇가지 일반적인 목적의 예외 클래스를 정의하며 내용은 표에 있다
* new 헤더에서는 bad_alloc 예외 타입을 정의하는데 이에 대해서는 12.1.2절에서 다른다. 
* type_info 헤더에서는 bad_cast 예외 타입을 정의하는데 이에 대해서는 19.2절에서 다룬다.

예외 클래스 라이브러리에는 모든 예외 타입 객체에 대해 생성, 복사, 대입을 할 수 있을 정도로 몇가지 연산만 있다.

|    에러 이름     |                            기능                             |
| :--------------: | :---------------------------------------------------------: |
|    exception     |                  가장 일반적인 유형의 문제                  |
|  runtime_error   |               실행 중에만 발견할 수 있는 문제               |
|   range_error    |    실행 중 오류 : 의미 있는 값 범위를 벗어나 생성된 결과    |
|  overflow_error  |               실행 중 오류 : 오버플로한 계산                |
| underflow_error  |                실행중 오류 : 언더플로한 계산                |
|   logic_error    |                   프로그램의 논리적 오류                    |
|   domain_error   |            논리 오류 : 결과가 존재하지 않는 인자            |
| invalid_argument |                논리오류 : 적절하지 않은 인자                |
|   length_error   | 논리 오류 : 해당 타입의 최대 크기보다 더 큰 객체 생성할려함 |
|   out_of_range   |          논리 오류 : 유효한 범위를 벗어난 값 사용           |

예외 타입에서 정의하는 연산은 what 하나뿐인데, 이 함수에서는 c형식 문자열에 대한 포인터인 const char*를 반환한다

# 함수

함수는 이름이 있는 구역이며 이 함수를 호출해 코드를 실행한다. 함수는 다중 정의할 수 있는데 이는 여러 다른 함수를 같은 이름으로 참조할 수 있음을 뜻한다

## 함수 기초

함수 정의는 기본적으로 반환타입, 이름, 없거나 하나 이상인 매개변수 목록, 본체로 구성한다.

함수는 괄호 쌍인 호출연산자를 통해 실행하는데, 이 연산자에서는 함수나 함수에 대한 포인터인 표현식을 취한다. 괄호 안쪽은 쉼표로 구분한 인자 목록이다. 이 인자는 함수 매개변수를 초기화 하는데 사용한다.

#### 함수 만들기

팩토리얼 프로그램을 만들어보자

```c++
int fact(int val)
{
    int ret = 1;
    while(val > 1)
        ret *= val--; //ret * val을 ret에 대입하고 val을 감소시킨다
    return ret;
}
```

#### 함수 호출하기

```c++
int main()
{
    int j = fact(5);
    cout << "5!는 " << j << endl;
    return 0;
}
```

함수 호출은 호출하는 함수의 실행을 잠시 멈추고 호출되는 함수의 실행을 시작한다.

#### 매개변수와 인자

인자를 매개변수로 초기화 한다. 각 인자 타입은 해당 매개변수의 타입과 일치해야 한다. 또한 함수에 전달하는 인자와 매개변수의 수는 정확히 같아야 한다.

#### 함수 매개변수 목록

함수 매개변수 목록은 비어 있을 수 있지만 생략 할 수는 없다. 매개변수의 타입이 같다고 해도 생략하면 안되고 각각 타입을 다 작성해줘야 한다. 그리고 매개변수의 이름이 같을 순 없다.

#### 함수 반환 타입

함수 반환 타입에는 타입 대부분은 사용할 수 있다. void는 반환 하지 않는다는 것이다. 하지만 배열 타입이나 함수 타입은 반환 타입으로 쓸 수 없다. 대신 함수에서는 배열 또는 함수에 대한 포인터를 반환할 수 있다.

### 지역 객체

c++에서는 이름에 유효 범위가 있으며 객체에는 수명이 있다.

* 이름의 유효 범위는 프로그램 본문에서 해당 이름을 볼 수 있는 부분이다
* 객체의 수명은 프로그램을 실행하는 동안 객체가 존재하는 시간이다.

함수 본체 안에서 정의한 매개변수와 변수를 지역 변수라 한다. 이 변수는 해당 함수로 한정되고 외부 유효 범위에서 같은 이름으로 만든 선언을 가린다.

함수 밖에서 정의한 객체는 전역변수라고 하며 프로그램을 실행하는 내내 존재한다. 이런 객체는 프로그램을 마칠 때까지 소멸하지 않는다.

#### 자동 객체

구역을 실행할 때만 존재하는 객체를 자동 객체라고 한다 매개변수와 지역변수도 자동 객체이다. 

#### 지역 static 객체

수명이 함수 호출을 너머 지속하는 지역 변수가 있으면 유용할 수 있다. 이런 객체는 지역 변수를 static으로 정의해 얻는다.

각 지역  static 객체는 해당 객체 정의를 처음 실행 하기 전에 초기화 한다 지역 static 변수는 함수를 마쳐도 소멸하지 않으며 프로그램을 종료할 때 소멸한다.

```c++
size_t count_calls()
{
    static size_t ctr = 0;
    return ++ctr;
}
int main()
{
    for (size_t i = 0; i != 10; ++i)
        cout << count_calls() << endl;
    return 0;
}
``` 

이 프로그램은 1부터 10까지 수를 출력하며 ctr은 함수가 종료 되어도 없어지지 않는다.

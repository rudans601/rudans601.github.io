---
layout: single
title: "C++ primer 16"
categories: C++_primer
tags: [c++]
author_profile: false
#search: false
---
### 함수 선언

함수 이름도 사용하기 전에 선언 해야 하고 변수와 마찬가지로 정의는 단 한번만 할 수 있으나 선언은 여러번 할 수 있다.

선언에는 함수 본체만 없다는 것만 제외하면 함수 선언은 함수 정의와 비슷하다. 선언에서는 세미콜론으로 함수 본체를 대신한다.

함수 선언에는 본체가 없으므로 매개변수 이름이 없어도 된다. 그래서 선언에서는 종종 매개변수 이름을 생략한다.



#### 함수 선언은 헤더 파일에 둔다

함수도 선언은 헤더 파일에서 하고 정의는 소스파일에 하는 것이 좋다.

헤더 파일을 사용해 함수를 선언하면 지정한 함수에 대한 모든 선언이 다른 곳에서도 일치함을 보장한다.

함수를 정의하는 소스파일에서는 해당 함수 선언을 담고 있는 헤더를 포함해야 한다.

### 분리 컴파일

프로그램이 더 복잡해져 갈수록 프로그램의 다양한 부분을 개별 파일에 저장하길 바랄 것이다. 

프로그램을 여러 논리적 부분으로 나눠 만들 수 있도록 c++에서는 분리 컴파일 이라고 하는 기능을 지원한다. 분리 컴파일을 통해 프로그램을 여러 파일로 나눌 수 있으며 그 각각을 독립적으로 컴파일할 수 있다.

#### 여러 소스 파일을 컴파일과 링크하기

책 참고

## 인자 전달

이미 알고 있든 함수를 호출할 때마다 매개변수를 생성하고 호출할 때 전달한 인자로 초기화한다.

다른 모든 변수와 마찬가지로 매개변수의 타입은 매개변수와 인자 사이에 상호작용을 결정한다.

매개변수가 참조자이면 그 매개변수는 해당 인자와 결합하고 그렇지 않으면 인자 값을 복사한다.

다른 참조자와 마찬가지로 참조자 매개변수는 결합하는 객체에 대한 별칭이다. 즉 매개변수는 해당 인자에 대한 별칭이다.

매개변수가 참조자이면 해당 인자를 참조로 전달 한다고 하거나 그 함수를 참조로 호출한다고 한다.

인자 값을 복사할 때는 인자를 값으로 전달 한다고 하거나 그 함수를 값으로 호출 한다고 한다.

### 값에 의한 인자 전달

비참조자 타입 변수를 초기화할 때는 초기화식의 값을 복사하며 그 변수를 변경하더라도 초기화식에는 영향을 주지 않는다. 인자에 아무런 영향을 줄 수 없다.

#### 포인터 매개변수

포인터는 비참조자 타입처럼 행동한다. 포인터를 복사할 때는 포인터 값을 복사하며, 복사 후 두 포인터는 별개이다. 하지만 포인터를 사용하면 그 포인터로 가리키는 객체에 간접적으로 접근할 수 있으므로, 해당 포인터를 통해 대입해 객체 값을 변경할 수 있다.

```c++
int n = 0, i = 42;
int *p = &n, *q = &i; //p는 n을 가리키고 q는 i를 가리킨다
*p = 42; //n값을 변경하지만 p는 변경하지 않는다
p = q; //이제 p는 i를 가리키며 i와 n 값은 변경하지 않는다
```

```c++
void reset(int *ip)
{
  *ip = 0; //ip로 가리키는 객체 값을 변경한다. 인자인 i의 값이 0으로 변경된다
  ip = 0; //ip의 지역 복사본만 변경하며 인자는 변경하지 않는다
}

int main()
{
  int i = 42;
  reset(&i); //i는 변경하지만 i의 주소는 변경하지 않는다
  cout << "i = " << i << endl; //i = 0을 출력한다
}
```

### 참조자로 인자 전달

참조자에 대한 연산은 실제 해당 참조장에서 참조하는 객체에 대한 연산이라는 것이다.

이전 절에서 만든 reset 함수를 참조자로 바꿀 수 있다

```c++
void reset(int &i) //i는 단지 reset에 전달하는 객체에 대한 다른 이름이다
{
  i = 0; //i로 참조하는 객체 값을 변경한다 j값이 0으로 변경된다
}

void main()
{
  int j = 42;
  reset(j); //j는 참조자로 전달하므로 j 값을 변경한다
  cout << "j = " << j << endl;
}
```

#### 참조자를 사용해 복사 피하기

크기가 큰 클래스 타입이나 컨테이너 객체를 복사하는 것은 비효율적일 수 있다. 게다가 IO타입을 포함해 일부 클래스 타입은 복사할 수 없다. 복사할 수 없는 타입인 객체와 연산하려면 함수에서는 참조자 매개변수를 사용해야 한다.

예를 들어 두 string 길이를 비교하는 함수를 만든다. string은 길이가 길 수 있어 복사를 피하고 싶으므로 매개변수를 참조자로 만든다. 두 string을 비교할 때 string을 변경하지 않으므로 두 매개변수를 const에 대한 참조자로 만든다

```c++
bool isShorter(const string &s1, const string &s2)
{
  return s1.size() < s2.size();
}
```

함수에서 참조자 매개변수를 변경할 필요가 없으면 이를 const에 대한 참조자로 사용하는 것이 좋다

#### 참조자 매개변수를 사용해 추가 정보 반환하기

함수에서는 값을 하나만 반환할 수 있다. 하지만 때론 함수에서 반환할 값이 하나 이상 있기도 하다. 이때 참조자 매개변수를 사용하면 여러 결과를 반환할 수 있다.

### const 매개변수와 인자

const 매개변수를 사용할 때는 상위 const를 기억하는 것이 중요하다. 상위 const는 객체 그 자체에 적용한다.

객체를 복사할 때 상위 const는 무시한다

```c++
const int ci = 42; //ci는 변경할 수 없다
int i = ci; //좋음 : ci를 복사할 때 상위 const는 무시한다
int * const p = &i; //const가 상위이므로 p에 대입할 수 없다
*p = 0; //좋음 : p를 통해 변경할 수 있으며 i는 이제 0이다 p에 담겨 있는 주소만 못 바꾸지 역참조는 가능
```

다른 모든 초기화와 마찬가지로 매개변수를 초기화 하기 위해 인자를 복사할 때는 상위 const를 무시하므로 결과적으로 매개변수의 상위 const는 무시한다. 즉 상위 const인 매개변수에 const와 const가 아닌 객체 어느 것이든 전달 할 수 있다.

```c++
void fcn(const int i)
{
  // fcn에서는 i를 읽을 수 있지만 기록할 수는 없다
}
```

c++에서는 여러 다른 함수를 같은 이름으로 정의 할 수 있다. 하지만 매개변수 목록이 달라야 한다.

#### 포인터 또는 참조자 매개변수와 const

매개변수는 변수 초기화와 같은 방식으로 초기화하므로 일반적인 초기화 규칙을 기억하는 것이 도움이 될 수 있다

const가 아닌 객체로 하위 const인 객체를 초기화할 수 있지만 역은 성립하지 않으므로 보통의 참조자는 같은 타입인 객체로 초기화 해야 한다

```c++
int i = 42;
const int *cp = &i; //좋음, 그러나 cp로 i를 바꿀 수 없다
const int &r = i; //좋음 : 그러나 r로 i를 바꿀 수 없다
const int &r2 = 42; //좋음
int *p = cp; //오류 : p와 cp의 타입이 일치하지 않는다
int &r3 = r; //오류 : r3와 r의 타입이 일치하지 않는다
int &r4 = 42; //오류 : 보통의 참조자는 상수로 초기화 할 수 없다
```

매개 변수를 전달할 때도 정확히 같은 규칙을 적용한다

```c++
int i = 0;
const int ci = i;
string::size_type ctr = 0;
reset(&i); //매개변수가 int*인 reset 버전을 호출한다
reset(&ci); //오류 : const int 객체의 포인터로 int*를 초기화할 수 없다
reset(i); //매개변수가 int&인 reset 버전을 호출한다
reset(ci); //오류 : 보통의 참조자를 const 객체인 ci와 결합할 수 없다
reset(42); //오류 : 보통의 참조자를 상수와 결합할 수 없다
reset(ctr); //오류 : 타입이 일치하지 않는다. ctr은 unsigned 타입이다
//좋음: find_char의 첫 매개변수는 const에 대한 참조자이다
find_char("Hello World!", 'o', ctr);
```

참조자 버전 reset은 int 객체에 대해서만 호출할 수 있으며 상수, int로 평가하는 표현식, 변환을 해야 하는 객체, const int 객체는 전달할 수 없다. 

마찬가지로 포인터 버전 reset은 int*만 전달할 수 있다. 

한편 find_char에는 첫 인자로 문자열 상수를 전달할 수 있다. 이 함수의 참조자 매개변수가 const에 대한 참조자인데 const에 대한 참조자는 상수로 초기화 할 수 있다.

#### 가능하면 const에 대한 참조자를 사용한다

함수에서 변경하지 않는 매개변수를 보통의 참조자로 정의하는 일은 다소 흔한 실수이다. 그렇게 하면 함수를 호출하는 쪽에서는 그 함수에서 인자 값을 변경할 것으로 오해할 수 있다. 게다가 const에 대한 참조자 대신 보통의 참조자를 사용하면 그 함수에 사용할 수 있는 인자의 타입을 심하게 제한하게 된다. 이미 보았듯이 보통의 참조자 매개변수에는 const 객체나 상수, 변환을 해야하는 객체를 전달할 수 없다. 하위 const객체로 보통의 참조자에 대입할 수 없기 때문이다

String 매개변수를 const에 대한 참조자로 올바르게 만든 find_char 함수의 매개변수를 보통의 string&로 정의 했다면

```c++
string::size_type find_char(string &s, char c, string::size_type &occurs);
```

Find_char는 string객체로만 호출할 수 있으며

```c++
find_char("Hello world", 'o', ctr);
```

로 호출하면 컴파일을 실패한다. 첫번째 인자는 const char*형태이기 때문이다. 

### 배열 매개변수

배열은 복사할 수 없으며 배열을 사용할 때 그 배열은 일반적으로 포인터로 변환한다. 배열은 복사할 수 없으므로 배열을 값으로 전달 할 수 없고, 배열은 포인터로 변환하므로 함수에 배열을 전달할 때 실제로는 해당 배열의 첫 요소에 대한 포인터를 전달한다

배열을 값으로 전달할 수 없을지라도 매개변수를 배열처럼 보이도록 만들 수 있다

```c++
//외양과 달리 print에 대한 이 세가지 선언은 같다
//각 함수에는 매개변수가 const int* 타입 하나이다
void print(const int*);
void print(const int[]);//함수에서 배열을 취한다는 의도를 나타낸다
void print(const int[10]); //문서화 목적을 표시한 차원
```

```c++
int i = 0, j[2] = {0,1};
print(&i); //좋음 : &i는 int*이다 
print(j); //좋음 : j는 j[0]을 가리키는 int*로 변환한다
```

print에 배열을 전달하면 인자는 자동으로 해당 배열에 대한 첫 요소로 변환하므로 배열 크기는 관계없다

배열은 포인터로 전달하므로 일반적으로 함수에서는 전달받는 배열의 크기를 알 수 없으며 호출하는 쪽에서 제공하는 추가 정보에 의존해야 한다. 

포인터 매개변수를 관리하는데 흔히 사용하는 기법에는 세 가지가 있다

#### 표시자를 사용한 배열 범위 지정하기

배열 인자를 관리하는 첫 번째 접근법은 배열 자체에 끝을 나타내는 표시자를 포함하는 것이다. c형식 문자열이 그 예이다. c형식 문자열은 문자열 내 마지막 문자 다음에 널 문자를 추가한 문자 배열에 저장한다. 

```c++
void print(const char *cp)
{
  if(cp) //cp가 널 포인터가 아니면
    while (*cp) //cp에서 가리키는 문자가 널 문자가 아닌 동안
      cout << *cp++; //해당 문자를 출력하고 포인터를 증가시킨다
}
```

#### 표준 라이브러리 변환 사용하기

배열 인자를 관리하는 두번째 기법은 배열의 첫 요소와 마지막 요소 바로 다음에 대한 포인터를 전달하는 것이다. 이 접근법은 표준 라이브러리에서 사용하는 기법에서 영감을 받았다. 

```c++
void print(const int *beg, const int *end)
{
  //beg에서 시작해 end를 제외한 모든 요소를 출력한다
  	while(beg != end)
      cout << *beg++ << endl; //현재 요소를 출력하고 포인터를 증가시킨다
}

int main()
{
  int j[2] = {0,1}; //j는 j의 첫 요소에 대한 포인터로 변환한다
  //두번째 인자는 j의 마지막 요소 바로 다음 위치에 대한 포인터이다
  print(begin(j), end(j)); //begin과 end함수는 3.5절 다시 복습
}
```

#### 크기 매개 변수를 명시적으로 전달하기

배열 인자에 대한 세번째 접근법은 c프로그램과 오래된 c++ 프로그램에서 일반적이었던 방법으로 배열 크기를 나타내는 두번째 매개변수를 정의하는 것이다. 이 접근법을 사용하면 print를 다음처럼 다시 만들 수 있다

```c++
//const int ia[]는 const int* ia와 같다
//size를 명시적으로 전달하고 ia 요소에 접근을 제어하는 데 사용한다
void print(const int ia[], size_t size)
{
  for (size_t i = 0; i!= size; ++i)
  {
    cout << ia[i] << endl;
  }
}

int main()
{
  int j[2] = {0,1}; //크기가 2인 int 배열
  print(j, end(j) - begin(j)); //begin과 end함수는 3.5절 다시 복습
}
```

이 버전에는 size 매개변수를 사용하여 출력할 요소가 얼마나 있는지 결정하므로 print를 호출할 때 추가 매개변수를 전달해야 한다



#### 배열 매개변수와 const

print 함수의 세가지 버전 모두 배열 매개변수는 const에 대한 포인터로 정의한다는 점에 주목한다. 함수에서 요소 값을 변경해야 할 경우에만 매개변수를 const가 아닌 타입에 대한 보통의 포인터로 사용해야 한다

#### 배열 참조자 매개변수

변수를 배열에 대한 참조자로 정의할 수 있는 것처럼 매개변수도 배열에 대한 참조자로 정의할 수 있다. 일반적으로 참조자 매개변수는 해당 인자, 이 예에서는 배열과 결합한다

```c++
//좋음 : 매개변수는 배열에 대한 참조자 이므로 차원은 타입의 일부분이다
void print(int (&arr)[10])
{
  for ( auto elem : arr)
    cout << elem << endl;
}
```

주의! 괄호로 &arr을 둘러싸야 한다. f(int &arr[10])은 arr을 참조자 배열로 선언한다

f(int (&arr)[10])은 intrk 10개인 배열에 대한 참조자이다



배열 크기는 해당 타입의 일부분이므로 함수 본체에서 그 차원을 사용해도 안전하다. 즉 이함수는 정확히 int가 10개인 배열에 대해서만 호출할 수 있다

#### 다차원 배열 전달하기

c++에는 다차원 배열이 없고 배열의 배열이 있다.

다른 배열과 마찬가지로 다차원 배열 역시 첫 요소에 대한 포인터로 전달한다. 배열의 배열을 다루므로 그 요소는 배열이고, 결국 그 포인터는 배열에 대한 포인터이다. 두번째( 그리고 그 이하) 차원 크기는 해당 요소 타입의 일부분이므로 반드시 지정해야 한다

```c++
void print(int(*matrix) [10], int rowSize) {//...}
```

에서는 matrix를 int가 10개인 배열에 대한 포인터로 선언한다

주의! 괄호로 matrix를 감싸야 한다

```c++
int *matrix[10]; //포인터가 10개인 배열
int (*matrix) [10]; //int가 10개인 배열에 대한 포인터
```

배열 문법을 사용해 함수를 정의할 수 있는데 일반적으로 컴파일러에서는 첫 번째 차원을 무시하므로 포함하지 않는 것이 좋다

```c++
//동일한 정의
void print(int matrix[][10], int rowSize) {//... }
```

에서는 matrix를 2차원 배열처럼 보이도록 선언하지만 사실 이 매개변수는 int가 10개인 배열에 대한 포인터이다



### main: 명령행 옵션 처리하기

책 참고

### 매개변수가 가변인 함수

함수에 인자가 얼마나 많이 전달해야 하는지 미리 알 수 없을 때 새로운 표준에서는 가변 인자수를 취하는 함수를 만들기 위한 두가지 기본적인 방법을 제공한다 즉 모든 인자 타입이 같으면 initializer_list라이브러리 타입을 전달할 수 있고, 인자 타입이 다양하면 가변인자 템플릿이라고 하는 특별한 함수를 만들 수 있다. 이에 대해서는 16.4절에서 다룬다

또한 c++에서는 개수가 가변인 인자를 전달하는데 사용할 수 있는 특별한 매개변수 타입인 매개변수 생략도 있으며 간단히 살펴본다 하지만 이 기능은 프로그램에서 c함수와 인터페이스 할 때만 사용하는 것이 좋다

#### initializer_list 매개변수

Initializer_list 매개변수를 사용하면 타입은 같지만 몇 개인지 모르는 인자를 취하는 함수를 만들 수 있다 initializer_list는 지정한 타입의 값을 요소로 하는 배열을 나타내는 라이브러리 타입이다. 타입은 initializer_list 헤더에서 정의한다.

vector처럼 initializer_list 역시 템플릿 타입 이므로 initializer_list를 정의할 때는 목록에 담을 요소 타입을 지정해야 한다

```c++
initializer_list<string>ls; //string의 initializer_list
initializer_list<int> li; //int의 initializer_list
```

vector와 달리 initializer_list 요소는 항상 const값이므로 요소 값을 변경할 방법이 없다

이를 사용하는 예는 다음과 같다

```c++
void error_msg(initializer_list<string> il)
{
  for(auto beg = il.begin(); beg != il.end(); ++beg)
    cout << *beg << " ";
  cout << endl;
}
```

값을 initializer_list 매개변수에 전달할 때는 그 순차열을 중괄호로 둘러 싸야 한다

```c++
if(expected != actual) //expected와 actual은 string이다
  error_msg({"functionX", expected, actual});
else
  error_msg({"functionX", "okay"});
```

|        initializer_list 연산         |                             기능                             |
| :----------------------------------: | :----------------------------------------------------------: |
|       initializer_list<T> let;       |        기본 초기화, 요소는 T타입이며 목록은 비어있다         |
| initializer_list <T> list{a,b,c,...} | lst에는 초기 값만큼 많은 요소가 있으며 요소는 해당 초기 값의 복사본이다. 목록 내 요소는 const이다 |
|              lst2(let)               | initializer_list를 복사하거나 대입하면 해당 목록의 요소를 복사하지 않는다. 복사 후에는 원래 것과 복사본 모두에서 해당 요소를 공유한다 |
|              lst2 = lst              |                          위와 동일                           |
|              lst.size()              |                         목록 요소 수                         |
|      lst.begin() 또는 lst.end()      | lst의 첫번째 요소에 대한 포인터와 마지막 요소 바로 다음에 대한 포인터를 반환한다 |

#### 매개변수 생략

c++에서는 매개변수 생략을 사용해 c라이브러리인 varargs를 사용하는 c코드와 프로그램을 인터페이스 할 수 있다. 일반적으로 매개변수 생략은 다른 목적으로 사용하지 않는 것이 좋다. 

매개 변수 생략은 c와 c++ 모두에서 공통인 타입에 대해서만 사용해야 한다. 특히 대부분의 클래스 타입 객체는 매개변수 생략에 전달할 때 제대로 복사되지 않는다

매개변수 생략은 매개변수 목록의 마지막 요소로만 사용할 수 있으며 다음 두 형식 중 하나로 쓸 수 있다

Void foo(parm_list, ...);

Void foo(...);

첫번째 형식에서는 foo 매개변수 중 일부에 대해서만 타입을 지정한다. 타입을 지정한 매개변수에 해당하는 인자는 일반적으로 타입을 확인하지만 매개변수 생략에 해당하는 인자는 타입을 확인하지 않는다. 첫번째 형식에서 매개변수 선언 다음에 오는 쉼표는 선택적이다
 